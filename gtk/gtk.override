/* -*- Mode: C; c-basic-offset: 4 -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"
#include "pygtktreemodel.h"

/* gross hack until gdk-pixbuf types get set up as normal enums/flags */
#define GDK_TYPE_COLORSPACE G_TYPE_INVALID
#define GDK_TYPE_INTERP_TYPE G_TYPE_INVALID
#define GDK_TYPE_PIXBUF_ALPHA_MODE G_TYPE_INVALID

static PyExtensionClass *_PyGObject_Type;
#define PyGObject_Type (*_PyGObject_Type)

static PyExtensionClass *_PyPangoContext_Type;
#define PyPangoContext_Type (*_PyPangoContext_Type)
static PyExtensionClass *_PyPangoFont_Type;
#define PyPangoFont_Type (*_PyPangoFont_Type)
static PyExtensionClass *_PyPangoLayout_Type;
#define PyPangoLayout_Type (*_PyPangoLayout_Type)

/* from the gdk portion ... */
extern PyExtensionClass PyGdkColormap_Type;
extern PyExtensionClass PyGdkGC_Type;
extern PyExtensionClass PyGdkWindow_Type;
extern PyExtensionClass PyGdkPixmap_Type;
extern PyExtensionClass PyGdkImage_Type;
extern PyExtensionClass PyGdkPixbuf_Type;
extern PyExtensionClass PyGdkPixbufAnimation_Type;
extern PyExtensionClass PyGdkDragContext_Type;


%%
init
{
    PyObject *pygobject = PyImport_ImportModule("gobject");
    PyObject *pypango;

    if (pygobject != NULL) {
	PyObject *module_dict = PyModule_GetDict(pygobject);

	_PyGObject_Type = (PyExtensionClass *)PyDict_GetItemString(module_dict,
								   "GObject");
    } else {
	Py_FatalError("could not import gobject");
	return;
    }
    pypango = PyImport_ImportModule("pango");
    if (pypango != NULL) {
	PyObject *module_dict = PyModule_GetDict(pypango);

	_PyPangoContext_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Context");
	_PyPangoFont_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Font");
	_PyPangoLayout_Type =
	    (PyExtensionClass *)PyDict_GetItemString(module_dict,
						     "Layout");
    } else {
	Py_FatalError("could not import pango");
	return;
    }
}

%%
ignore gtk_selection_data_copy gtk_selection_data_free
%%
override-attr GtkSelectionData.data
if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
    return PyString_FromStringAndSize(
			pyg_boxed_get(self, GtkSelectionData)->data,
			pyg_boxed_get(self, GtkSelectionData)->length);
} else {
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iis#:GtkSelectionData.set", kwlist,
				     &type, &format, &data, &length))
	return NULL;
    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
			   type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_draw kwargs
static PyObject *
_wrap_gtk_widget_draw(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "rect", NULL };
    GdkRectangle rect;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.draw",
				     kwlist, &(rect.x), &(rect.y),
				     &(rect.width), &(rect.height)))
        return NULL;
    gtk_widget_draw(GTK_WIDGET(self->obj), &rect);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_size_request
static PyObject *
_wrap_gtk_widget_size_request(PyGObject *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.size_request"))
        return NULL;
    gtk_widget_size_request(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_size_allocate kwargs
static PyObject *
_wrap_gtk_widget_size_allocate(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "allocation", NULL };
    GtkAllocation allocation;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs,
				    "(hhhh):GtkWidget.size_allocate", kwlist,
				    &(allocation.x), &(allocation.y),
				    &(allocation.width), &(allocation.height)))
        return NULL;
    gtk_widget_size_allocate(GTK_WIDGET(self->obj), &allocation);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_widget_get_child_requisition
static PyObject *
_wrap_gtk_widget_get_child_requisition(PyGObject *self, PyObject *args)
{
    GtkRequisition requisition;

    if (!PyArg_ParseTuple(args,":GtkWidget.get_child_requisition"))
        return NULL;
    gtk_widget_get_child_requisition(GTK_WIDGET(self->obj), &requisition);
    return Py_BuildValue("(ii)", requisition.width, requisition.height);
}
%%
override gtk_widget_get_allocation
static PyObject *
_wrap_gtk_widget_get_allocation(PyGObject *self, PyObject *args)
{
    GtkAllocation allocation;

    if (!PyArg_ParseTuple(args, ":GtkWidget.get_allocation"))
	return NULL;
    allocation = GTK_WIDGET(self->obj)->allocation;
    return Py_BuildValue("(iiii)", (int)allocation.x, (int)allocation.y,
			 (int)allocation.width, (int)allocation.height);
}
%%
override gtk_widget_intersect kwargs
static PyObject *
_wrap_gtk_widget_intersect(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "area", NULL };
    GdkRectangle area;
    GdkRectangle intersect;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "(hhhh):GtkWidget.intersect",
				    kwlist, &(area.x), &(area.y),
				    &(area.width), &(area.height))) 
        return NULL;
    if (gtk_widget_intersect(GTK_WIDGET(self->obj), &area, &intersect))
        return Py_BuildValue("(iiii)", (int)intersect.x, (int)intersect.y,
                             (int)intersect.width, (int)intersect.height);
    else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_widget_get_pointer
static PyObject *
_wrap_gtk_widget_get_pointer(PyGObject *self, PyObject *args)
{
    int x, y;

    if (!PyArg_ParseTuple(args, ":GtkWidget.get_pointer"))
	return NULL;
    gtk_widget_get_pointer(GTK_WIDGET(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_container_children
static PyObject *
_wrap_gtk_container_children(PyGObject *self, PyObject *args)
{
    GList *list, *tmp;
    PyObject *py_list;
    PyObject *gtk_obj;

    if(!PyArg_ParseTuple(args,":GtkContainer.children"))
        return NULL;
    list = gtk_container_children(GTK_CONTAINER(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
	g_list_free(list);
	return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	gtk_obj = pygobject_new(G_OBJECT(tmp->data));
	if (gtk_obj == NULL) {
	    g_list_free(list);
	    Py_DECREF(py_list);
	    return NULL;
	}
	PyList_Append(py_list, gtk_obj);
	Py_DECREF(gtk_obj);
    }
    g_list_free(list);
    return py_list;
}
%%
override gtk_label_get
static PyObject *
_wrap_gtk_label_get(PyGObject *self, PyObject *args)
{
    gchar *text = NULL;

    if (!PyArg_ParseTuple(args, ":GtkLabel.get"))
	return NULL;
    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
	return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_window_set_geometry_hints kwargs
static PyObject *
_wrap_gtk_window_set_geometry_hints(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "geometry_widget", "min_width", "min_height",
			      "max_width", "max_height", "base_width",
			      "base_height", "width_inc", "height_inc", NULL };
    PyObject *py_geometry_widget = Py_None;
    GtkWidget *geometry_widget = NULL;
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"|Oiiiiiiiidd:GtkWindow.set_geometry_hints", kwlist,
				     &py_geometry_widget, &min_width,
				     &min_height, &max_width, &max_height,
				     &base_width, &base_height, &width_inc,
				     &height_inc, &min_aspect, &max_aspect))
	return NULL;
    if (pygobject_check(py_geometry_widget, &PyGtkWidget_Type))
	geometry_widget = GTK_WIDGET(pygobject_get(py_geometry_widget));
    else if (py_geometry_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"geometry_widget must be a GtkWidget or None");
	return NULL;
    }
    if (min_width >= 0 || min_height >= 0) {
	geometry.min_width = MAX(min_width, 0);
	geometry.min_height = MAX(min_height, 0);
	geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
	geometry.max_width = MAX(max_width, 0);
	geometry.max_height = MAX(max_height, 0);
	geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
	geometry.base_width = MAX(base_width, 0);
	geometry.base_height = MAX(base_height, 0);
	geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
	geometry.width_inc = MAX(width_inc, 0);
	geometry.height_inc = MAX(height_inc, 0);
	geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
	if (min_aspect <= 0.0 || max_aspect <= 0.0) {
	    PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
	    return NULL;
	}
	geometry.min_aspect = min_aspect;
	geometry.max_aspect = max_aspect;
	geom_mask |= GDK_HINT_ASPECT;
    }
    gtk_window_set_geometry_hints(GTK_WINDOW(self->obj), geometry_widget,
				  &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkBox.query_child_packing", kwlist,
				     &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "first arg should be a GtkWidget");
	return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
				GTK_WIDGET(child->obj), &expand, &fill,
				&padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
ignore gtk_clist_new
%%
override gtk_clist_new_with_titles kwargs
static PyObject *
_wrap_gtk_clist_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "count", "titles", NULL };
    int count, i;
    PyObject *py_list = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|O:GtkCList.__init__",
				     kwlist, &count, &py_list))
	return NULL;
    if (py_list) {
	gchar **list;

	if (!PySequence_Check(py_list)) {
	    PyErr_SetString(PyExc_TypeError,"2nd argument not a sequence");
	    return NULL;
	}
	if (PySequence_Length(py_list) < count) {
	    PyErr_SetString(PyExc_TypeError, "sequence not long enough");
	    return NULL;
	}
	list = g_new(gchar *, count);
	for (i = 0; i < count; i++) {
	    PyObject *item = PySequence_GetItem(py_list, i);

	    Py_DECREF(item); /* PySequence_GetItem INCREF's */
	    if (!PyString_Check(item)) {
		PyErr_SetString(PyExc_TypeError, "sequence item not a string");
		g_free(list);
		return NULL;
	    }
	    list[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_clist_new_with_titles(count, list);
	g_free(list);
    } else
	self->obj = (GObject *)gtk_clist_new(count);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCList object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_text kwargs
static PyObject *
_wrap_gtk_clist_get_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_text",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_text(GTK_CLIST(self->obj), r, c, &text) || text==NULL) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_clist_get_pixmap kwargs
static PyObject *
_wrap_gtk_clist_get_pixmap(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixmap",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixmap(GTK_CLIST(self->obj), r, c,
			      &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_get_pixtext kwargs
static PyObject *
_wrap_gtk_clist_get_pixtext(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "row", "column", NULL };
    int r, c;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkCList.get_pixtext",
				     kwlist, &r, &c))
	return NULL;
    if (!gtk_clist_get_pixtext(GTK_CLIST(self->obj), r, c,
			      &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(ziNN)", text, (gint)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_clist_prepend kwargs
static PyObject *
_wrap_gtk_clist_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.prepend",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_prepend(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_append kwargs
static PyObject *
_wrap_gtk_clist_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    int col, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCList.append",
				     kwlist, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_append(GTK_CLIST(self->obj), list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_insert kwargs
static PyObject *
_wrap_gtk_clist_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "row", "text", NULL };
    int col, row, i;
    PyObject *py_list;
    gchar **list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.insert",
				     kwlist, &row, &py_list))
	return NULL;
    if (!PySequence_Check(py_list)) {
	PyErr_SetString(PyExc_TypeError, "argument not a sequence");
	return NULL;
    }
    col = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_list) < col) {
	PyErr_SetString(PyExc_TypeError, "sequnce too short");
	return NULL;
    }
    list = g_new(gchar *, col);
    for (i = 0; i < col; i++) {
	PyObject *item = PySequence_GetItem(py_list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_free(list);
	    return NULL;
	}
	list[i] = PyString_AsString(item);
    }
    i = gtk_clist_insert(GTK_CLIST(self->obj), row, list);
    g_free(list);
    return PyInt_FromLong(i);
}
%%
override gtk_clist_set_row_data kwargs
static PyObject *
_wrap_gtk_clist_set_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", "data", NULL };
    int row;
    PyObject *data;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iO:GtkCList.set_row_data",
				     kwlist, &row, &data))
	return NULL;
    Py_INCREF(data);
    gtk_clist_set_row_data_full(GTK_CLIST(self->obj), row, data,
				(GtkDestroyNotify)pygtk_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clist_get_row_data kwargs
static PyObject *
_wrap_gtk_clist_get_row_data(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "row", NULL };
    PyObject *ret;
    int row;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkCList.get_row_data",
				     kwlist, &row))
        return NULL;
    ret = gtk_clist_get_row_data(GTK_CLIST(self->obj), row);
    if (!ret) ret = Py_None;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_clist_find_row_from_data kwargs
static PyObject *
_wrap_gtk_clist_find_row_from_data(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCList.find_row_from_data", kwlist,
				     &data))
        return NULL;
    return PyInt_FromLong(gtk_clist_find_row_from_data(
				GTK_CLIST(self->obj), data));
}
%%
override gtk_clist_get_selection_info kwargs
static PyObject *
_wrap_gtk_clist_get_selection_info(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", NULL };
    gint x, y, row, column;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "ii:GtkCList.get_selection_info", kwlist,
				     &x, &y))
	return NULL;
    if (gtk_clist_get_selection_info(GTK_CLIST(self->obj), x, y,
				     &row, &column))
	return Py_BuildValue("(ii)", row, column);
    else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}   
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkCombo.set_popdown_strings", kwlist,
				     &list))
	return NULL;
    if (!PySequence_Check(list)) {
	PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
	return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PySequence_GetItem(list, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError, "sequence item not a string");
	    g_list_free(glist);
	    return NULL;
	}
	glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|i:GtkCurve.get_vector", kwlist,
				     &size))
	return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
	PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
			   PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
				     kwlist, &seq))
	return NULL;
    if (!PySequence_Check(seq)) {
	PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
	return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
	PyObject *item = PySequence_GetItem(seq, i);

	Py_DECREF(item);
	item = PyNumber_Float(item); /* item has a ref now */
	if (item == NULL) {
	    g_free(vector);
	    return NULL;
	}
	vector[i] = PyFloat_AsDouble(item);
	Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_model_get_iter
static PyObject *
_wrap_gtk_tree_model_get_iter(PyGObject *self, PyObject *args) {
    GtkTreeIter iter;
    GtkTreePath *path;

    path = pygtk_tree_path_from_pyobject(args);
    if (!path) {
	PyErr_SetString(PyExc_TypeError, "GtkTreeModel.get_iter requires at least one integer argument");
	return NULL;
    }
    if (gtk_tree_model_get_iter(GTK_TREE_MODEL(self->obj), &iter, path)) {
	gtk_tree_path_free(path);
	return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
    } else {
	gtk_tree_path_free(path);
	PyErr_SetString(PyExc_ValueError, "invalid tree path");
	return NULL;
    }
}
%%
override gtk_tree_model_get_value kwargs
static PyObject *
_wrap_gtk_tree_model_get_value(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *ret;
    gint column;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args,kwargs, "Oi:GtkTreeModel.get_value",
				     kwlist, &iter, &column))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_tree_model_get_value(GTK_TREE_MODEL(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    ret = pyg_value_as_pyobject(&value);
    g_value_unset(&value);
    return ret;
}
%%
ignore gtk_list_store_newv
%%
override gtk_list_store_new
static PyObject *
_wrap_gtk_list_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_list_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkListStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_set_value kwargs
static PyObject *
_wrap_gtk_list_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkListStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value, GTK_LIST_STORE(self->obj)->column_headers[column]);
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_list_store_set_value(GTK_LIST_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_store_insert kwargs
static PyObject *
_wrap_gtk_list_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "position", NULL };
    GtkTreeIter iter;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkListStore.insert",
				     kwlist, &position))
	return NULL;
    gtk_list_store_insert(GTK_LIST_STORE(self->obj), &iter, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_before kwargs
static PyObject *
_wrap_gtk_list_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_before",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_before(GTK_LIST_STORE(self->obj), &iter,
				 pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_insert_after kwargs
static PyObject *
_wrap_gtk_list_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "sibling", NULL };
    PyObject *sibling;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkListStore.insert_after",
				     kwlist, &sibling))
	return NULL;
    if (!pyg_boxed_check(sibling, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    gtk_list_store_insert_after(GTK_LIST_STORE(self->obj), &iter,
				pyg_boxed_get(sibling, GtkTreeIter));
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_prepend
static PyObject *
_wrap_gtk_list_store_prepend(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkListStore.prepend"))
	return NULL;
    gtk_list_store_prepend(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_list_store_append
static PyObject *
_wrap_gtk_list_store_append(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkListStore.append"))
	return NULL;
    gtk_list_store_append(GTK_LIST_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore gtk_tree_store_newv
%%
override gtk_tree_store_new
static PyObject *
_wrap_gtk_tree_store_new(PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;

    len = PyTuple_Size(args);
    column_types = g_new(GType, len);
    for (i = 0; i < len; i++) {
	PyObject *item = PyTuple_GetItem(args, i);

	column_types[i] = pyg_type_from_object(item);
	if (column_types[i] == 0) {
	    g_free(column_types);
	    return NULL;
	}
    }
    self->obj = (GObject *)gtk_tree_store_newv(len, column_types);
    g_free(column_types);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GtkTreeStore object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_store_set_value kwargs
static PyObject *
_wrap_gtk_tree_store_set_value(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "iter", "column", "value", NULL };
    PyObject *iter, *pyvalue;
    gint column;
    GValue value = { 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OiO:GtkTreeStore.set_value",
				     kwlist, &iter, &column, &pyvalue))
	return NULL;
    if (column < 0 ||
	column >= gtk_tree_model_get_n_columns(GTK_TREE_MODEL(self->obj))) {
	PyErr_SetString(PyExc_ValueError, "column number is out of range");
	return NULL;
    }
    if (!pyg_boxed_check(iter, GTK_TYPE_TREE_ITER)) {
	PyErr_SetString(PyExc_TypeError, "iter must be a GtkTreeIter");
	return NULL;
    }
    g_value_init(&value, GTK_TREE_STORE(self->obj)->column_headers[column]);
    if (pyg_value_from_pyobject(&value, pyvalue)) {
	PyErr_SetString(PyExc_TypeError,
			"value is of the wrong type for this column");
	return NULL;
    }
    gtk_tree_store_set_value(GTK_TREE_STORE(self->obj),
			     pyg_boxed_get(iter, GtkTreeIter), column, &value);
    g_value_unset(&value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gtk_tree_store_set
  gtk_tree_store_setv
  gtk_tree_store_get
  gtk_tree_store_getv
%%
override gtk_tree_store_insert kwargs
static PyObject *
_wrap_gtk_tree_store_insert(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "position", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;
    gint position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GtkTreeStore.insert",
				     kwlist, &py_parent, &position))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert(GTK_TREE_STORE(self->obj), &iter, parent, position);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_before kwargs
static PyObject *
_wrap_gtk_tree_store_insert_before(PyGObject *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_before",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_before(GTK_TREE_STORE(self->obj), &iter, parent,
				 sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_insert_after kwargs
static PyObject *
_wrap_gtk_tree_store_insert_after(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", NULL };
    PyObject *py_parent, *py_sibling;
    GtkTreeIter iter, *parent = NULL, *sibling = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkTreeStore.insert_after",
				     kwlist, &py_parent, &py_sibling))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    if (pyg_boxed_check(py_sibling, GTK_TYPE_TREE_ITER))
	sibling = pyg_boxed_get(py_sibling, GtkTreeIter);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sibling must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_insert_after(GTK_TREE_STORE(self->obj), &iter, parent,
				sibling);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_prepend kwargs
static PyObject *
_wrap_gtk_tree_store_prepend(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.prepend",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_prepend(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_append kwargs
static PyObject *
_wrap_gtk_tree_store_append(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", NULL };
    PyObject *py_parent;
    GtkTreeIter iter, *parent = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTreeStore.append",
				     kwlist, &py_parent))
	return NULL;
    if (pyg_boxed_check(py_parent, GTK_TYPE_TREE_ITER))
	parent = pyg_boxed_get(py_parent, GtkTreeIter);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"parent must be a GtkTreeIter or None");
	return NULL;
    }
    gtk_tree_store_append(GTK_TREE_STORE(self->obj), &iter, parent);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_tree_store_get_root_iter
static PyObject *
_wrap_gtk_tree_store_get_root_iter(PyGObject *self, PyObject *args)
{
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTreeStore.get_root_iter"))
	return NULL;
    gtk_tree_store_get_root_iter(GTK_TREE_STORE(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);
}
%%
ignore
  gtk_tree_view_new
  gtk_tree_view_column_new_with_attributes
%%
override gtk_tree_view_column_new kwargs
static PyObject *
_wrap_gtk_tree_view_column_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    PyObject *py_cell = NULL, *key, *item;
    GtkTreeViewColumn *tvc;
    gchar *title = NULL;
    GtkCellRenderer *cell = NULL;
    gint i = 0;

    if (!PyArg_ParseTuple(args, "|zO:GtkTreeViewColumn.__init__", &title,
			  &py_cell))
	return NULL;
    if (py_cell != NULL) {
	if (pygobject_check(py_cell, &PyGtkCellRenderer_Type))
	    cell = GTK_CELL_RENDERER(pygobject_get(py_cell));
	else if (py_cell != Py_None) {
	    PyErr_SetString(PyExc_TypeError,
			    "cell must be a GtkCellRenderer or None");
	    return NULL;
	}
    }
    tvc = gtk_tree_view_column_new();
    if (title)
	gtk_tree_view_column_set_title(tvc, title);
    if (cell)
	gtk_tree_view_column_set_cell_renderer(tvc, cell);
    if (kwargs) {
	while (PyDict_Next(kwargs, &i, &key, &item)) {
	    gchar *attr = PyString_AsString(key);

	    if (!PyInt_Check(item)) {
		gchar err[128];
		g_snprintf(err, sizeof(err),
			   "%s must be an integer column number", attr);
		PyErr_SetString(PyExc_TypeError, err);
		g_object_unref(G_OBJECT(tvc));
		return NULL;
	    }
	    gtk_tree_view_column_add_attribute(tvc, cell, attr,
					       PyInt_AsLong(item));
	}
    }
    self->obj = (GObject *)tvc;
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_tree_view_get_path_at_pos kwargs
static PyObject *
_wrap_gtk_tree_view_get_path_at_pos(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "window", "x", "y", NULL };
    PyGObject *window;
    gint x, y;
    GtkTreePath *path;
    GtkTreeViewColumn *column;
    gint cell_x, cell_y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oii:GtkTreeView.get_path_at_pos",
				     kwlist, &window, &x, &y))
	return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
	PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow");
	return NULL;
    }
    if (gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(self->obj),
				      GDK_WINDOW(window->obj), x, y,
				      &path, &column, &cell_x, &cell_y)) {
	PyObject *ret = PyTuple_New(4);

	if (path) {
	    PyTuple_SetItem(ret, 0, pygtk_tree_path_to_pyobject(path));
	    gtk_tree_path_free(path);
	} else {
	    Py_INCREF(Py_None);
	    PyTuple_SetItem(ret, 0, Py_None);
	}
	PyTuple_SetItem(ret, 1, pygobject_new((GObject *)column));
	PyTuple_SetItem(ret, 2, PyInt_FromLong(cell_x));
	PyTuple_SetItem(ret, 3, PyInt_FromLong(cell_y));
	return ret;
    } else {
	Py_INCREF(Py_None);
	return Py_None;
    }
}
%%
override gtk_tree_selection_get_selected
static PyObject *
_wrap_gtk_tree_selection_get_selected(PyGObject *self, PyObject *args)
{
    GtkTreeModel *model;
    GtkTreeIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTreeSelection.get_selected"))
	return NULL;
    if (gtk_tree_selection_get_selected(GTK_TREE_SELECTION(self->obj),
					&model, &iter))
	return Py_BuildValue("(NN)", pygobject_new((GObject *)model),
			     pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal

static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
	PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
			" least 4 arguments");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
			  &keyval, &modifiers, &signal_name)) {
	Py_DECREF(first);
	return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
	return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
	PyErr_SetString(PyExc_ValueError,
			"GtkBindingSet.add_signal requires an even number"
			" of parameter pairs following the first four args");
	return NULL;
    }
    for (i=4; i < len; i+=2) {
	PyObject *item;
	GType arg_type;
	GtkBindingArg *arg = NULL;

	item = PyTuple_GET_ITEM(args, i);
	arg_type = pyg_type_from_object(item);
	if (!arg_type) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "GtkBindingSet.add_signal parameter types"
			    " must be int");
	    goto arg_error;
	}
	arg = g_new0 (GtkBindingArg, 1);
	slist = g_slist_prepend(slist, arg);
    
	arg->arg_type = arg_type;
	switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
	case GTK_TYPE_CHAR:
	case GTK_TYPE_UCHAR:
	case GTK_TYPE_INT:
	case GTK_TYPE_UINT:
	case GTK_TYPE_BOOL:
	case GTK_TYPE_ENUM:
	case GTK_TYPE_FLAGS:
	case GTK_TYPE_LONG:
	case GTK_TYPE_ULONG:
	    arg->arg_type = GTK_TYPE_LONG;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyInt_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be int", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (glong)PyInt_AsLong(item);
	    break;
	case GTK_TYPE_FLOAT:
	case GTK_TYPE_DOUBLE:
	    arg->arg_type = GTK_TYPE_DOUBLE;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyFloat_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal "
					 "arg[%u] must be float", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
	    break;
	case GTK_TYPE_STRING:
	    arg->arg_type = GTK_TYPE_STRING;
	    if (arg->arg_type != GTK_TYPE_IDENTIFIER)
		arg->arg_type = GTK_TYPE_STRING;
	    item = PyTuple_GET_ITEM(args, i+1);
	    if (!PyString_Check(item)) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    arg->d.string_data = (gchar*)PyString_AsString(item);
	    if (!arg->d.string_data) {
		errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
					 "must be non-empty string", i+1);
		PyErr_SetString(PyExc_TypeError, errmsg);
		g_free(errmsg);
		goto arg_error;
	    }
	    break;
	default:
	    errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
				     "type %10s for arg[%u]",
				     gtk_type_name(arg->arg_type), i+1);
	    PyErr_SetString(PyExc_TypeError, errmsg);
	    g_free(errmsg);
	    goto arg_error;
	} /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
	g_slist_foreach(slist, (GFunc)g_free, NULL);
	g_slist_free(slist);
    }
    return NULL;
}

/* -------------- haven't updated stuff below this line -------------- */
%%
ignore-glob
  *_get_type
  gtk_marshal_*
  gtk_arg_*
  gtk_args_*
  gtk_signal_connect*
  gtk_signal_add_emission_hook*
  gtk_signal_new*
  gtk_draw_*
  gtk_paint_*
  gtk_init_add_*
  gtk_quit_add_*
  gtk_timeout_add_*
  gtk_idle_add_*
  gtk_accelerator_*
  gtk_target_list_*
  gtk_pattern_*
  gtk_gc_*
  gtk_signal_*
  gtk_tree_path_*
%%
ignore
  gtk_binding_set_new
  gtk_binding_set_by_class
  gtk_binding_set_find
  gtk_binding_set_clear
  gtk_init
  gtk_init_check
  gtk_exit
  gtk_set_locale
  gtk_accel_group_ref
  gtk_accel_group_unref
  gtk_accel_groups_activate
  gtk_accel_group_activate
  gtk_accel_group_attach
  gtk_accel_group_detach
  gtk_accel_group_get_entry
  gtk_accel_group_lock_entry
  gtk_accel_group_unlock_entry
  gtk_accel_group_add
  gtk_accel_group_remove
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_groups_from_object
  gtk_accel_group_entries_from_object
  gtk_signal_set_funcs
  gtk_signal_lookup
  gtk_signal_disconnect_by_func
  gtk_signal_disconnect_by_data
  gtk_signal_handler_block_by_func
  gtk_signal_handler_block_by_data
  gtk_signal_handler_unblock_by_func
  gtk_signal_handler_unblock_by_data
  gtk_signal_handler_pending_by_func
  gtk_signal_n_emissions
  gtk_signal_n_emissions_by_name
  gtk_signal_name
  gtk_signal_remove_emission_hook
  gtk_signal_query
  gtk_signal_emit
  gtk_signal_emit_by_name
  gtk_signal_emitv
  gtk_signal_emitv_by_name
  gtk_quit_remove_by_data
  gtk_idle_remove_by_data
  gtk_object_weakref
  gtk_object_weakunref
  gtk_object_get
  gtk_object_getv
  gtk_object_set
  gtk_object_setv
  gtk_object_set_data
  gtk_object_set_data_full
  gtk_object_get_data
  gtk_object_set_user_data
  gtk_object_get_user_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_get_data_by_id
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_arg_set
  gtk_object_arg_get
  gtk_trace_referencing
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_set
  gtk_widget_setv
  gtk_container_get_toplevels
  gtk_container_add_child_arg_type
  gtk_container_query_child_args
  gtk_container_child_args_collect
  gtk_container_child_arg_get_info
  gtk_container_foreach
  gtk_container_foreach_full
  gtk_container_forall
  gtk_container_child_getv
  gtk_container_child_setv
  gtk_container_add_with_args
  gtk_container_addv
  gtk_container_child_set
  gtk_container_arg_set
  gtk_container_arg_get
  gtk_progress_bar_new
  gtk_clist_set_row_data_full
  gtk_window_add_embedded_xid
  gtk_window_remove_embedded_xid
  gtk_range_trough_click
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_tooltips_data_get
  gtk_type_check_object_cast
  gtk_type_check_class_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_preview_uninit
  gtk_item_factory_create_item
  gtk_item_factory_delete_entry
  gtk_item_factory_delete_entries
  gtk_item_factory_popup_with_data
  gtk_item_factory_popup_data
  gtk_item_factory_set_translate_func
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_menu_attach_to_widget
  gtk_radio_menu_item_group
  gtk_radio_menu_item_set_group
  gtk_radio_button_group
  gtk_radio_button_set_group
%%
ignore gtk_object_new gtk_object_newv gtk_object_query_args
  gtk_object_add_arg_type gtk_object_args_collect gtk_object_arg_get_info
  gtk_widget_new gtk_widget_newv
%%
ignore gtk_true gtk_false gtk_key_snooper_install gtk_key_snooper_remove
  gtk_get_current_event gtk_get_event_widget gtk_propagate_event
%%
override gtk_main
static PyObject *
_wrap_gtk_main(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":main"))
	return NULL;

    pygtk_unblock_threads();
    gtk_main();
    pygtk_block_threads();
    if (PyErr_Occurred())
	return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
				    &block)) 
        return NULL;
    pygtk_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pygtk_block_threads();
    return PyInt_FromLong(ret);
}
%%
override gtk_timeout_add
static PyObject *
_wrap_gtk_timeout_add(PyObject *self, PyObject *args)
{
    guint32 interval;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"timeout_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:timeout_add", &interval, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_timeout_add_full(interval, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_idle_add
static PyObject *
_wrap_gtk_idle_add(PyObject *self, PyObject *args)
{
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 1) {
	PyErr_SetString(PyExc_TypeError,
			"idle_add requires at least 1 arg");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 1);
    if (!PyArg_ParseTuple(first, "O:idle_add", &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "first arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 1, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_quit_add
static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
	PyErr_SetString(PyExc_TypeError,
			"quit_add requires at least 2 args");
	return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
	Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second arg not callable");
        return NULL;
    }
    cbargs = PySequence_GetSlice(args, 2, len);

    if (cbargs == NULL)
      return NULL;
    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, NULL,
        (GtkCallbackMarshal)pygtk_handler_marshal,
        data, (GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_input_add_full kwargs
static PyObject *
_wrap_gtk_input_add_full(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "source", "condition", "callback", NULL };
    int source;
    GdkInputCondition condition;
    PyObject *callback;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iiO:input_add", kwlist,
				     &source, &condition, &callback))
        return NULL;
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "3rd arg not callable.");
        return NULL;
    }
    Py_INCREF(callback);
    return PyInt_FromLong(gtk_input_add_full(source, condition, NULL,
			(GtkCallbackMarshal)pygtk_input_marshal, callback,
			(GtkDestroyNotify)pygtk_destroy_notify));
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    char *text;
    int len, pos;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"s#:GtkEditable.insert_text",
				     kwlist, &text, &len))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &pos);
    return PyInt_FromLong(pos);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyObject *callback, guint action, GtkWidget *widget)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(callback, "iO", action,
				pygobject_new((GObject *)widget));
    if (ret == NULL) {
	if (PyGtk_FatalExceptions)
	    gtk_main_quit();
	else {
	    PyErr_Print();
	    PyErr_Clear();
	}
    } else
	Py_DECREF(ret);
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", NULL };
    PyObject *list, *cb;
    GtkItemFactoryEntry ent;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkItemFactory.create_items", kwlist,
				     &PyList_Type, &list))
	return NULL;
    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PyList_Size(list);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(list, i);

	if (!PyArg_ParseTuple(item, "zzOiz", &(ent.path), &(ent.accelerator),
			      &cb, &(ent.callback_action), &(ent.item_type)))
	    return NULL;
	if (cb == Py_None)
	    ent.callback = NULL;
	else {
	    Py_INCREF(cb);
	    ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
	}
	gtk_item_factory_create_item(ifact, &ent, cb, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, PyObject *func)
{
    PyObject *ret;

    pygtk_block_threads();
    ret = PyObject_CallFunction(func, "Oii", pygobject_new((GObject *)menu),
                                *x, *y);
    if (ret == NULL || !PyArg_ParseTuple(ret, "ii", x, y)) {
        if (PyGtk_FatalExceptions)
            gtk_main_quit();
        else {
            PyErr_Print();
            PyErr_Clear();
        }
        if (ret) {
          Py_DECREF(ret);
        }
    } else {
        Py_DECREF(ret);
    }
    pygtk_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
		       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button, time;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOii:GtkMenu.popup",
				     kwlist, &py_pms, &py_pmi, &func,
				     &button, &time))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (func != Py_None) {
	Py_INCREF(func);
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
		       (GtkMenuPositionFunc)pygtk_menu_position,
		       func, button, time);
    } else
	gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self, PyObject *args)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTuple(args, ":GtkPixmap.get"))
	return NULL;
    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}

%%
ignore gtk_button_new_with_label gtk_button_new_from_stock gtk_button_new_with_mnemonic
%%
override gtk_button_new kwargs
static PyObject *
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", NULL };
    gchar *text = NULL, *stock = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zz:GtkButton.__init__",
				     kwlist, &text, &stock))
	return NULL;
    if (stock)
	self->obj = (GObject *)gtk_button_new_from_stock(stock);
    else if (text)
	self->obj = (GObject *)gtk_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_toggle_button_new_with_label gtk_toggle_button_new_with_mnemonic
%%
override gtk_toggle_button_new kwargs
static PyObject *
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkToggleButton.__init__", kwlist,
				     &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_toggle_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_toggle_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_button_new_with_label gtk_check_button_new_with_mnemonic
%%
override gtk_check_button_new kwargs
static PyObject *
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:GtkCheckButton.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_check_button_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_button_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore-glob gtk_radio_button_new_*
%%
override gtk_radio_button_new kwargs
static PyObject *
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|Oz:GtkRadioButton.__init__",
				     kwlist, &py_group, &label))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
	group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioButton or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_button_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
	else
	    self->obj = (GObject *)gtk_radio_button_new_with_mnemonic
		(group->group, label);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_item_new_with_label
%%
override gtk_list_item_new kwargs
static PyObject *
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
	self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_menu_item_new_with_label gtk_menu_item_new_with_mnemonic
%%
override gtk_menu_item_new kwargs
static PyObject *
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkMenuItem.__init__",
				     kwlist, &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_check_menu_item_new_with_label gtk_check_menu_item_new_with_mnemonic
%%
override gtk_check_menu_item_new kwargs
static PyObject *
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|z:GtkCheckMenuItem.__init__", kwlist,
				     &text))
	return NULL;
    if (text)
	self->obj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    else
	self->obj = (GObject *)gtk_check_menu_item_new();
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_radio_menu_item_new_with_label gtk_radio_menu_item_new_with_mnemonic
%%
override gtk_radio_menu_item_new kwargs
static PyObject *
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|Oz:GtkRadioMenuItem.__init__", kwlist,
				     &py_group, &text))
	return NULL;
    if (py_group == Py_None)
	group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
	group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
	PyErr_SetString(PyExc_TypeError,
			"first argument must be a GtkRadioMenuItem or None");
	return NULL;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new(NULL);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new(group->group);
    } else {
	if (group == NULL)
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,
									 text);
	else
	    self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic
		(group->group, text);
    }
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_ctree_construct
  gtk_ctree_insert_gnode
  gtk_ctree_export_to_gnode
  gtk_ctree_post_recursive
  gtk_ctree_post_recursive_to_depth
  gtk_ctree_pre_recursive
  gtk_ctree_pre_recursive_to_depth
  gtk_ctree_find_node_ptr
%%
ignore gtk_ctree_new
%%
override gtk_ctree_new_with_titles kwargs
static PyObject*
_wrap_gtk_ctree_new_with_titles(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "columns", "tree_column", "titles", NULL };
    int columns, tree_column;
    PyObject *py_titles = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii|O:GtkCTree.__init__",
				     kwlist, &columns, &tree_column,
				     &py_titles))
	return NULL;
    if (py_titles) {
	gchar **titles;
	gint i;

	if (!PySequence_Check(py_titles)) {
	    PyErr_SetString(PyExc_TypeError, "titles must be a sequence");
	    return NULL;
	}
	if (PySequence_Length(py_titles) < columns) {
	    PyErr_SetString(PyExc_TypeError, "titles too short");
	    return NULL;
	}
	titles = g_new(gchar *, columns);
	for (i = 0; i < columns; i++) {
	    PyObject *item = PySequence_GetItem(py_titles, i);

	    Py_DECREF(item);
	    if (!PyString_Check(item)) {
		PyErr_SetString(PyExc_TypeError, "sequence item not a string");
		g_free(titles);
		return NULL;
	    }
	    titles[i] = PyString_AsString(item);
	}
	self->obj = (GObject *)gtk_ctree_new_with_titles(columns,
						tree_column, titles);
	g_free(titles);
    } else
	self->obj = (GObject *)gtk_ctree_new(columns, tree_column);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,"could not create GtkCTree object");
	return NULL;
    }
    gtk_object_ref(GTK_OBJECT(self->obj));
    gtk_object_sink(GTK_OBJECT(self->obj));
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_insert_node kwargs
static PyObject *
_wrap_gtk_ctree_insert_node(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "sibling", "text", "spacing",
			      "pixmap_closed", "mask_closed", "pixmap_opened",
			      "mask_opened", "is_leaf", "expanded", NULL };
    PyObject *py_parent, *py_sibling, *py_text;
    PyGObject *py_pixmap_closed, *py_mask_closed;
    PyGObject *py_pixmap_opened, *py_mask_opened;
    GtkCTreeNode *parent = NULL, *sibling = NULL, *ret;
    gchar **text = NULL;
    GdkPixmap *pixmap_closed = NULL, *pixmap_opened = NULL;
    GdkBitmap *mask_closed = NULL, *mask_opened = NULL;
    gint spacing, is_leaf, expanded, columns, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOOiOOOOii:GtkCTree.insert_node", kwlist,
				     &py_parent, &py_sibling, &py_text,
				     &spacing, &py_pixmap_closed,
				     &py_mask_closed, &py_pixmap_opened,
				     &py_mask_opened, &is_leaf, &expanded))
	return NULL;
    if (PyGtkCTreeNode_Check(py_parent))
	parent = PyGtkCTreeNode_Get(py_parent);
    else if (py_parent != Py_None) {
	PyErr_SetString(PyExc_TypeError, "parent must be a CTreeNode or None");
	return NULL;
    }
    if (PyGtkCTreeNode_Check(py_sibling))
	sibling = PyGtkCTreeNode_Get(py_sibling);
    else if (py_sibling != Py_None) {
	PyErr_SetString(PyExc_TypeError,"sibling must be a CTreeNode or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_closed, &PyGdkPixmap_Type))
	pixmap_closed = GDK_PIXMAP(py_pixmap_closed->obj);
    else if ((PyObject *)py_pixmap_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_closed must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_closed, &PyGdkPixmap_Type))
	mask_closed = GDK_PIXMAP(py_mask_closed->obj);
    else if ((PyObject *)py_mask_closed != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_closed must be a GdkBitmap or None");
	return NULL;
    }
    if (pygobject_check(py_pixmap_opened, &PyGdkPixmap_Type))
	pixmap_opened = GDK_PIXMAP(py_pixmap_opened->obj);
    else if ((PyObject *)py_pixmap_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"pixmap_opened must be a GdkPixmap or None");
	return NULL;
    }
    if (pygobject_check(py_mask_opened, &PyGdkPixmap_Type))
	mask_opened = GDK_PIXMAP(py_mask_opened->obj);
    else if ((PyObject *)py_mask_opened != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"mask_opened must be a GdkBitmap or None");
	return NULL;
    }
    if (!PySequence_Check(py_text)) {
	PyErr_SetString(PyExc_TypeError, "text must be a sequence");
	return NULL;
    }
    columns = GTK_CLIST(self->obj)->columns;
    if (PySequence_Length(py_text) < columns) {
	PyErr_SetString(PyExc_TypeError, "text is too short");
	return NULL;
    }
    text = g_new(gchar *, columns);
    for (i = 0; i < columns; i++) {
	PyObject *item = PySequence_GetItem(py_text, i);

	Py_DECREF(item);
	if (!PyString_Check(item)) {
	    PyErr_SetString(PyExc_TypeError,"text sequence item not a string");
	    g_free(text);
	    return NULL;
	}
	text[i] = PyString_AsString(item);
    }
    ret = gtk_ctree_insert_node(GTK_CTREE(self->obj), parent, sibling, text,
				spacing, pixmap_closed, mask_closed,
				pixmap_opened, mask_opened, is_leaf, expanded);
    g_free(text);
    return PyGtkCTreeNode_New(ret);
}
%%
ignore gtk_ctree_find_by_row_data_custom gtk_ctree_find_all_by_row_data_custom
%%
override gtk_ctree_find_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_by_row_data(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *py_node, *data;
    GtkCTreeNode *node = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_by_row_data", kwlist,
				     &py_node, &data))
	return NULL;
    if (PyGtkCTreeNode_Check(py_node))
	node = PyGtkCTreeNode_Get(py_node);
    else if (py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_by_row_data(GTK_CTREE(self->obj), node, data);
    if (ret)
	return PyGtkCTreeNode_New(ret);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_find_all_by_row_data kwargs
static PyObject *
_wrap_gtk_ctree_find_all_by_row_data(PyGObject *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *py_node, *data, *list;
    GtkCTreeNode *node = NULL;
    GList *ret, *tmp;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OO:GtkCTree.find_all_by_row_data",kwlist,
				     &py_node, &data))
	return NULL;
    if (PyGtkCTreeNode_Check(py_node))
	node = PyGtkCTreeNode_Get(py_node);
    else if (py_node != Py_None) {
	PyErr_SetString(PyExc_TypeError, "node must be a CTreeNode or None");
	return NULL;
    }
    ret = gtk_ctree_find_all_by_row_data(GTK_CTREE(self->obj), node, data);
    if ((list = PyList_New(0)) == NULL)
	return NULL;
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *item = PyGtkCTreeNode_New((GtkCTreeNode *)tmp->data);

	if (item == NULL) {
	    Py_DECREF(list);
	    return NULL;
	}
	PyList_Append(list, item);
	Py_DECREF(item);
    }
    g_list_free(ret);
    return list;
}
%%
override gtk_ctree_node_get_text kwargs
static PyObject *
_wrap_gtk_ctree_node_get_text(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    char *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_text", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_text(GTK_CTREE(self->obj),
				 PyGtkCTreeNode_Get(node), column, &text)) {
	PyErr_SetString(PyExc_ValueError, "can't get text value");
	return NULL;
    }
    return PyString_FromString(text);
}
%%
override gtk_ctree_node_get_pixmap kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixmap(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_pixmap", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_pixmap(GTK_CTREE(self->obj),
				   PyGtkCTreeNode_Get(node), column,
				   &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixmap value");
	return NULL;
    }
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_node_get_pixtext kwargs
static PyObject *
_wrap_gtk_ctree_node_get_pixtext(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "node", "column", NULL };
    PyObject *node;
    int column;
    gchar *text = NULL;
    guint8 spacing;
    GdkPixmap *pixmap = NULL;
    GdkBitmap *mask = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!i:GtkCTree.node_get_pixtext", kwlist,
				     &PyGtkCTreeNode_Type, &node, &column))
	return NULL;
    if (!gtk_ctree_node_get_pixtext(GTK_CTREE(self->obj),
				   PyGtkCTreeNode_Get(node), column,
				   &text, &spacing, &pixmap, &mask)) {
	PyErr_SetString(PyExc_ValueError, "can't get pixtext value");
	return NULL;
    }
    return Py_BuildValue("(siNN)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_ctree_get_node_info kwargs
static PyObject *
_wrap_gtk_ctree_get_node_info(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node;
    gchar *text;
    guint8 spacing;
    GdkPixmap *pixmap_closed, *pixmap_opened;
    GdkBitmap *mask_closed, *mask_opened;
    gboolean is_leaf, expanded;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkCTree.get_node_info",
				     kwlist, &PyGtkCTreeNode_Type, &node))
	return NULL;
    if (!gtk_ctree_get_node_info(GTK_CTREE(self->obj),PyGtkCTreeNode_Get(node),
				 &text, &spacing, &pixmap_closed, &mask_closed,
				 &pixmap_opened, &mask_opened,
				 &is_leaf, &expanded)) {
	PyErr_SetString(PyExc_ValueError, "can't get node info");
	return NULL;
    }
    return Py_BuildValue("(siNNNNii)", text, (int)spacing,
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_closed),
			 pygobject_new((GObject *)pixmap_opened),
			 pygobject_new((GObject *)mask_opened),
			 (int)is_leaf, (int)expanded);
}
%%
ignore gtk_ctree_node_set_row_data_full
%%
override gtk_ctree_node_set_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_set_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", "data", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!O:GtkCTree.node_set_row_data", kwlist,
				     &PyGtkCTreeNode_Type, &node, &data))
	return NULL;
    Py_INCREF(data);
    gtk_ctree_node_set_row_data_full(GTK_CTREE(self->obj),
				     PyGtkCTreeNode_Get(node), data,
				     (GtkDestroyNotify)pygtk_destroy_notify);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_ctree_node_get_row_data kwargs
static PyObject *
_wrap_gtk_ctree_node_get_row_data(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "node", NULL };
    PyObject *node, *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkCTree.node_get_row_data", kwlist,
				     &PyGtkCTreeNode_Type, &node))
	return NULL;
    data = gtk_ctree_node_get_row_data(GTK_CTREE(self->obj),
				       PyGtkCTreeNode_Get(node));
    if (!data) data = Py_None;
    Py_INCREF(data);
    return data;
}
%%
ignore gtk_tree_remove_items
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.append_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOO:GtkToolbar.prepend_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
			      "icon", "callback", "user_data", "position",
			      NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "zzzOOOi:GtkToolbar.insert_item", kwlist,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"forth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
				  tooltip_private_text, icon, NULL, NULL,
				  position);
    if (ret && PyCallable_Check(callback)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.append_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
				  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOO:GtkToolbar.prepend_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
				      text, tooltip_text, tooltip_private_text,
				      icon, NULL, NULL);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
			      "tooltip_private_text", "icon", "callback",
			      "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOzzzOOOi:GtkToolbar.insert_element",
				     kwlist,
				     &py_type, &py_widget,
				     &text, &tooltip_text,
				     &tooltip_private_text, &py_icon,
				     &callback, &param, &position))
	return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
			   py_type, (gint *)&type))
	return NULL;
    if (!pygobject_check(py_widget, &PyGtkWidget_Type))
	widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"second argument must be a GtkWidget or None");
	return NULL;
    }
    if (!pygobject_check(py_icon, &PyGtkWidget_Type))
	icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
	PyErr_SetString(PyExc_TypeError,
			"sixth argument must be a GtkWidget or None");
	return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
				     text, tooltip_text, tooltip_private_text,
				     icon, NULL, NULL, position);
    if (ret && PyCallable_Check(callback) &&
	(type == GTK_TOOLBAR_CHILD_BUTTON ||
	 type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
	 type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
	g_signal_connect_closure(ret, "clicked",
				 pyg_closure_new(callback, param, NULL),
				 FALSE);
    }
    return pygobject_new((GObject *)ret);
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
					   PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkNotebook.query_tab_label_packing",
				     kwlist, &child))
	return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
	PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
	return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
					 GTK_WIDGET(child->obj),
					 &expand, &fill, &pack_type);
    return Py_BuildValue("(iii)", expand, fill, pack_type);
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
				     kwlist, &PyList_Type, &py_items,
				     &position))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
			     PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
				     kwlist, &PyList_Type, &py_items))
	return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
	PyObject *item = PyList_GetItem(py_items, i);
	if (!pygobject_check(item, &PyGtkListItem_Type)) {
	    PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
	    g_list_free(items);
	    return NULL;
	}
	items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_list_remove_items_no_unref
%%
override gtk_color_selection_get_current_color
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self, PyObject *args)
{
    GdkColor colour = { 0, };

    if (!PyArg_ParseTuple(args, ":GtkColorSelection.get_current_color"))
        return NULL;
    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
					  &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self, PyObject *args)
{
    GdkColor colour = { 0, };

    if (!PyArg_ParseTuple(args, ":GtkColorSelection.get_previous_color"))
        return NULL;
    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
					   &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self, PyObject *args)
{
    guint year, month, day;

    if (!PyArg_ParseTuple(args, ":GtkCalendar.get_date"))
	return NULL;
    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_dest_set", kwlist,
				     &py_flags, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
		      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOO:GtkWidget.drag_source_set", kwlist,
				     &py_sbmask, &py_targets, &py_actions))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
			     py_sbmask, (gint *)&sbmask))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
			actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "OOiO:GtkWidget.drag_begin", kwlist,
				     &py_targets, &py_actions, &button,
				     &event))
	return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
			     py_actions, (gint *)&actions))
	return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
	PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
	return NULL;
    }
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &tents[i].target,
			      &tents[i].flags, &tents[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(tents);
	    return NULL;
	}
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
			     pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    return pygobject_new((GObject *)context);
}
%%
ignore
  gtk_drag_source_handle_event gtk_drag_dest_handle_event
  gtk_selection_request gtk_selection_notify gtk_selection_property_notify
  gtk_selection_incr_event
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
				PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets;
    GtkTargetEntry *targets;
    int selection, n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "iO:GtkWidget.selection_add_targets",
				     kwlist, &selection, &py_targets))
	return NULL;
    if (!PySequence_Check(py_targets)) {
	PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
	return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
	PyObject *item = PySequence_GetItem(py_targets, i);
	Py_DECREF(item);
	if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
			      &targets[i].flags, &targets[i].info)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "list items should be of form (string,int,int)");
	    g_free(targets);
	    return NULL;
	}
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), (GdkAtom)selection,
			      targets, n_targets);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gtk_text_iter_free
%%
override gtk_text_iter_copy
static PyObject *
_wrap_gtk_text_iter_copy(PyGBoxed *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":GtkTextIter.copy"))
	return NULL;
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, pyg_boxed_get(self, GtkTextIter),
			 TRUE, TRUE);
}
%%
override gtk_text_iter_get_char
static PyObject *
_wrap_gtk_text_iter_get_char(PyGBoxed *self, PyObject *args)
{
    gunichar chr;
    Py_UNICODE pychr;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_char"))
	return NULL;
    chr = gtk_text_iter_get_char(pyg_boxed_get(self, GtkTextIter));
    if (chr > 0xffff) {
	PyErr_SetString(PyExc_RuntimeError, "python's broken unicode handling only supports 16 bit unicode, and you just hit this limit");
	return NULL;
    }
    pychr = (Py_UNICODE)chr;
    return PyUnicode_FromUnicode(&pychr, 1);

}
%%
override gtk_text_iter_get_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_slice(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_slice",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_slice(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_text(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextIter.get_text",
				     kwlist, &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_text(pyg_boxed_get(self, GtkTextIter),
				   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_slice kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_slice(PyGBoxed *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_slice", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_slice(pyg_boxed_get(self, GtkTextIter),
					   pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_visible_text kwargs
static PyObject *
_wrap_gtk_text_iter_get_visible_text(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "end", NULL };
    PyGBoxed *end;
    gchar *text;
    PyObject *pytext;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:GtkTextIter.get_visible_text", kwlist,
				     &end))
	return NULL;
    if (!pyg_boxed_check(end, GTK_TYPE_TEXT_ITER)) {
	PyErr_SetString(PyExc_TypeError, "end must be a GtkTextIter");
	return NULL;
    }
    text = gtk_text_iter_get_visible_text(pyg_boxed_get(self, GtkTextIter),
					  pyg_boxed_get(end, GtkTextIter));
    pytext = PyUnicode_DecodeUTF8(text, strlen(text), "strict");
    g_free(text);
    return pytext;
}
%%
override gtk_text_iter_get_marks
static PyObject *
_wrap_gtk_text_iter_get_marks(PyGBoxed *self, PyObject *args)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_marks"))
	return NULL;
    ret = gtk_text_iter_get_marks(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *mark = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, mark);
	Py_DECREF(mark);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_toggled_tags kwargs
static PyObject *
_wrap_gtk_text_iter_get_toggled_tags(PyGBoxed *self, PyObject *args,
				     PyObject *kwargs)
{
    static char *kwlist[] = { "toggled_on", NULL };
    GSList *ret, *tmp;
    int toggled_on;
    PyObject *pyret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:GtkTextIter.get_toggled_tags", kwlist,
				     &toggled_on))
	return NULL;
    ret = gtk_text_iter_get_toggled_tags(pyg_boxed_get(self, GtkTextIter),
					 toggled_on);
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_get_tags
static PyObject *
_wrap_gtk_text_iter_get_tags(PyGBoxed *self, PyObject *args)
{
    GSList *ret, *tmp;
    PyObject *pyret;

    if (!PyArg_ParseTuple(args, ":GtkTextIter.get_tags"))
	return NULL;
    ret = gtk_text_iter_get_tags(pyg_boxed_get(self, GtkTextIter));
    pyret = PyList_New(0);
    for (tmp = ret; tmp != NULL; tmp = tmp->next) {
	PyObject *tag = pygobject_new((GObject *)tmp->data);
	PyList_Append(pyret, tag);
	Py_DECREF(tag);
    }
    g_slist_free(ret);
    return pyret;
}
%%
override gtk_text_iter_forward_search kwargs
static PyObject *
_wrap_gtk_text_iter_forward_search(PyGBoxed *self, PyObject *args,
				   PyObject *kwargs)
{
    static char *kwlist[] = { "str", "visible_only", "slice", "limit", NULL };
    gchar *str;
    gint visible_only, slice;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sii|O:GtkTextIter.forward_search",
				     kwlist, &str, &visible_only, &slice,
				     &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_forward_search(pyg_boxed_get(self, GtkTextIter), str,
				     visible_only, slice, &match_start,
				     &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_iter_backward_search kwargs
static PyObject *
_wrap_gtk_text_iter_backward_search(PyGBoxed *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "str", "visible_only", "slice", "limit", NULL };
    gchar *str;
    gint visible_only, slice;
    PyObject *py_limit = Py_None;
    GtkTextIter match_start, match_end, *limit = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "sii|O:GtkTextIter.backward_search",
				     kwlist, &str, &visible_only, &slice,
				     &py_limit))
	return NULL;
    if (pyg_boxed_check(py_limit, GTK_TYPE_TEXT_ITER))
	limit = pyg_boxed_get(py_limit, GtkTextIter);
    else if (py_limit != Py_None) {
	PyErr_SetString(PyExc_TypeError,"limit must be a GtkTextIter or None");
	return NULL;
    }
    if (gtk_text_iter_backward_search(pyg_boxed_get(self, GtkTextIter), str,
				      visible_only, slice, &match_start,
				      &match_end, limit))
	return Py_BuildValue("(NN)",
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_start,
					   TRUE, TRUE),
			     pyg_boxed_new(GTK_TYPE_TEXT_ITER, &match_end,
					   TRUE, TRUE));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_buffer_create_tag kwargs
static PyObject *
_wrap_gtk_text_buffer_create_tag(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "tag_name", NULL };
    gchar *tag_name;
    GtkTextTag *tag;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:GtkTextBuffer.create_tag", kwlist,
				     &tag_name))
	return NULL;
    tag = gtk_text_buffer_create_tag(GTK_TEXT_BUFFER(self->obj),
				     tag_name, NULL);
    return pygobject_new((GObject *)tag);
}
%%
override gtk_text_buffer_get_iter_at_line_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "char_offset", NULL };
    GtkTextIter iter;
    int line_number, char_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_offset", kwlist, &line_number, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_offset(GTK_TEXT_BUFFER(self->obj), &iter,
					    line_number, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line_index kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line_index(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "line_number", "byte_offset", NULL };
    GtkTextIter iter;
    int line_number, byte_offset;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:GtkTextBuffer.get_iter_at_line_index", kwlist, &line_number, &byte_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_line_index(GTK_TEXT_BUFFER(self->obj), &iter,
					   line_number, byte_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_offset kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_offset(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int char_offset;
    static char *kwlist[] = { "char_offset", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_offset", kwlist, &char_offset))
        return NULL;

    gtk_text_buffer_get_iter_at_offset(GTK_TEXT_BUFFER(self->obj),
				       &iter, char_offset);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_iter_at_line kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_line(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    int line_number;
    static char *kwlist[] = { "line_number", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i:GtkTextBuffer.get_iter_at_line", kwlist, &line_number))
        return NULL;

    gtk_text_buffer_get_iter_at_line(GTK_TEXT_BUFFER(self->obj),
				     &iter, line_number);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_start_iter
static PyObject *
_wrap_gtk_text_buffer_get_start_iter(PyGObject *self, PyObject *args)
{
    GtkTextIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_start_iter"))
        return NULL;

    gtk_text_buffer_get_start_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_end_iter
static PyObject *
_wrap_gtk_text_buffer_get_end_iter(PyGObject *self, PyObject *args)
{
    GtkTextIter iter;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_end_iter"))
        return NULL;

    gtk_text_buffer_get_end_iter(GTK_TEXT_BUFFER(self->obj), &iter);
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}
%%
override gtk_text_buffer_get_bounds
static PyObject *
_wrap_gtk_text_buffer_get_bounds(PyGObject *self, PyObject *args)
{
    GtkTextIter start, end;

    if (!PyArg_ParseTuple(args, ":GtkTextBuffer.get_bounds"))
        return NULL;

    gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(self->obj), &start, &end);
    return Py_BuildValue("(NN)",
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &start, TRUE, TRUE),
			 pyg_boxed_new(GTK_TYPE_TEXT_ITER, &end, TRUE, TRUE));
}
%%
override gtk_text_buffer_get_iter_at_mark kwargs
static PyObject *
_wrap_gtk_text_buffer_get_iter_at_mark(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyGObject *mark;
    static char *kwlist[] = { "mark", NULL };
    GtkTextIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkTextBuffer.get_iter_at_mark", kwlist, &mark))
        return NULL;
    if (!pygobject_check(mark, &PyGtkTextMark_Type)) {
        PyErr_SetString(PyExc_TypeError, "mark should be a GtkTextMark");
        return NULL;
    }

    gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(self->obj), &iter,
				     GTK_TEXT_MARK(mark->obj));
    return pyg_boxed_new(GTK_TYPE_TEXT_ITER, &iter, TRUE, TRUE);
}


