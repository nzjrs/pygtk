/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   gtk.override: overrides for the gtk module.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include "pygtk-private.h"

#define PYGTK_CONTAINER_FOREACH 0
#define PYGTK_CONTAINER_FORALL 1
#define countof(array) (sizeof(array)/sizeof(array[0]))

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

/* from the gdk portion ... */
extern PyTypeObject PyGdkColormap_Type;
extern PyTypeObject PyGdkGC_Type;
extern PyTypeObject PyGdkWindow_Type;
extern PyTypeObject PyGdkPixmap_Type;
extern PyTypeObject PyGdkImage_Type;
extern PyTypeObject PyGdkPixbuf_Type;
extern PyTypeObject PyGdkPixbufAnimation_Type;
extern PyTypeObject PyGdkDragContext_Type;
extern PyTypeObject PyGdkDisplay_Type;
extern PyTypeObject PyGdkScreen_Type;
%%
include 
  gtkclist.override
  gtkcontainer.override
  gtkctree.override
  gtkstyle.override
  gtktextview.override
  gtktreeview.override
  gtkwidget.override
  gtkwindow.override
%%
modulename gtk
%%
import gobject.GObject as PyGObject_Type
import atk.Object as PyAtkObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore 
%%
ignore
  gtk_accel_group_add
  gtk_accel_group_create_add
  gtk_accel_group_create_remove
  gtk_accel_group_entries_from_object
  gtk_accel_group_get_entry
  gtk_accel_group_handle_add
  gtk_accel_group_handle_remove
  gtk_accel_group_lock_entry
  gtk_accel_group_ref
  gtk_accel_group_remove
  gtk_accel_groups_activate
  gtk_accel_groups_from_object
  gtk_accel_group_unlock_entry
  gtk_accel_group_unref
  gtk_binding_set_by_class
  gtk_binding_set_clear
  gtk_binding_set_find
  gtk_binding_set_new
  gtk_button_new_from_stock
  gtk_button_new_with_label
  gtk_button_new_with_mnemonic
  gtk_check_button_new_with_label
  gtk_check_button_new_with_mnemonic
  gtk_check_menu_item_new_with_label
  gtk_check_menu_item_new_with_mnemonic
  gtk_dialog_new
  gtk_drag_dest_handle_event
  gtk_drag_source_handle_event
  gtk_entry_new
  gtk_entry_select_region
  gtk_exit
  gtk_false 
  gtk_gc_get
  gtk_gc_release
  gtk_get_current_event
  gtk_get_event_widget
  gtk_idle_add
  gtk_idle_add_full
  gtk_idle_add_priority
  gtk_idle_remove
  gtk_idle_remove_by_data
  gtk_image_item_menu_new_with_label
  gtk_image_menu_item_new_from_stock
  gtk_image_menu_item_new_with_mnemonic
  gtk_init
  gtk_init_abi_check
  gtk_init_check
  gtk_init_check_abi_check
  gtk_input_add_full
  gtk_input_remove
  gtk_item_factory_create_item
  gtk_item_factory_create_items_ac
  gtk_item_factory_create_menu_entries
  gtk_item_factory_delete_entries
  gtk_item_factory_delete_entry
  gtk_item_factory_popup_data
  gtk_item_factory_popup_with_data
  gtk_item_factory_set_translate_func
  gtk_key_snooper_install
  gtk_key_snooper_remove
  gtk_list_item_new_with_label
  gtk_list_remove_items_no_unref
  gtk_menu_append
  gtk_menu_bar_append
  gtk_menu_bar_insert
  gtk_menu_bar_prepend
  gtk_menu_insert
  gtk_menu_item_new_with_label
  gtk_menu_item_new_with_mnemonic
  gtk_menu_prepend
  gtk_object_add_arg_type 
  gtk_object_arg_get
  gtk_object_arg_get_info
  gtk_object_args_collect 
  gtk_object_arg_set
  gtk_object_get
  gtk_object_get_data
  gtk_object_get_data_by_id
  gtk_object_get_user_data
  gtk_object_getv
  gtk_object_new 
  gtk_object_newv 
  gtk_object_query_args
  gtk_object_ref
  gtk_object_remove_data_by_id
  gtk_object_remove_no_notify_by_id
  gtk_object_set
  gtk_object_set_data
  gtk_object_set_data_by_id
  gtk_object_set_data_by_id_full
  gtk_object_set_data_full
  gtk_object_set_user_data
  gtk_object_setv
  gtk_object_sink
  gtk_object_unref
  gtk_object_weakref
  gtk_object_weakunref
  gtk_plug_construct
  gtk_plug_construct_for_display
  gtk_preview_uninit
  gtk_progress_bar_new
  gtk_propagate_event
  gtk_quit_remove_by_data
  gtk_radio_button_group
  gtk_radio_menu_item_group
  gtk_radio_menu_item_new_with_label
  gtk_radio_menu_item_new_with_mnemonic
  gtk_range_default_htrough_click
  gtk_range_default_vtrough_click
  gtk_range_trough_click
  gtk_selection_clear
  gtk_selection_data_copy
  gtk_selection_data_free
  gtk_selection_incr_event
  gtk_selection_notify
  gtk_selection_property_notify
  gtk_selection_request
  gtk_set_locale
  gtk_timeout_remove
  gtk_toggle_button_new_with_label
  gtk_toggle_button_new_with_mnemonic
  gtk_trace_referencing
  gtk_tree_remove_items
  gtk_true 
  gtk_type_check_class_cast
  gtk_type_check_object_cast
  gtk_type_register_enum
  gtk_type_register_flags
  gtk_widget_destroyed
  gtk_widget_get
  gtk_widget_getv
  gtk_widget_new 
  gtk_widget_newv
  gtk_widget_ref
  gtk_widget_set
  gtk_widget_setv
  gtk_widget_style_get_valist
  gtk_widget_unref
  gtk_rc_find_pixmap_in_path
  gtk_rc_scanner_new
  gtk_rc_parse_color
  gtk_rc_parse_state
  gtk_rc_parse_priority
  gtk_rc_property_parse_color
  gtk_rc_property_parse_enum
  gtk_rc_property_parse_flags
  gtk_rc_property_parse_requisition
  gtk_rc_property_parse_border
%%
ignore-glob
  _*
  *_get_type
  *_ref
  *_unref
  gtk_arg_*
  gtk_args_*
  gtk_draw_*
  gtk_init_add_*
  gtk_marshal_*
  gtk_pattern_*
  gtk_radio_button_new_*
  gtk_quit_add_*
  gtk_signal_*
  gtk_target_list_*
  gtk_timeout_add*
%%
ignore-win32
  GTK_TYPE_PLUG
  GTK_TYPE_SOCKET
  gtk_socket_new
  gtk_socket_steal
  gtk_socket_add_id
  gtk_socket_get_id
  gtk_plug_new
  gtk_plug_new_for_display
  gtk_plug_get_id
%%
override gtk_paint_polygon kwargs
static PyObject *
_wrap_gtk_paint_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "state_type", "shadow_type", "area", "widget", "detail", "points", "fill", NULL };
    PyObject *window, *py_state_type, *py_shadow_type, *py_area;
    GtkStateType state_type;
    GtkShadowType shadow_type;
    GdkRectangle area;
    PyObject *widget;
    const gchar *detail;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;
    gboolean fill;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!OOOO!zOi:GdkStyle.paint_polygon",
                                     kwlist, &PyGdkWindow_Type, &window,
                                     &py_state_type, &py_shadow_type, &py_area,
                                     &PyGtkWidget_Type, &widget, &detail,
                                     &py_points, &fill))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_STATE_TYPE, py_state_type,
                           (gint *)&state_type))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_SHADOW_TYPE, py_shadow_type,
                           (gint *)&shadow_type))
        return NULL;
    if (!pygdk_rectangle_from_pyobject(py_area, &area))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "hh", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gtk_paint_polygon(GTK_STYLE(self->obj), GDK_WINDOW(pygobject_get(window)),
                      state_type, shadow_type, &area,
                      GTK_WIDGET(pygobject_get(widget)), detail,
                      points, npoints, fill);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkSelectionData.data
static PyObject *
_wrap_gtk_selection_data__get_data(PyGObject *self, void *closure)
{
    if (pyg_boxed_get(self, GtkSelectionData)->length >= 0) {
        return PyString_FromStringAndSize(
                        pyg_boxed_get(self, GtkSelectionData)->data,
                        pyg_boxed_get(self, GtkSelectionData)->length);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gtk_selection_data_set kwargs
static PyObject *
_wrap_gtk_selection_data_set(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "type", "format", "data", NULL };
    PyObject *py_type;
    GdkAtom type;
    int format, length;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Ois#:GtkSelectionData.set", kwlist,
                                     &py_type, &format, &data, &length))
        return NULL;
    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;

    gtk_selection_data_set(pyg_boxed_get(self, GtkSelectionData),
                           type, format, data, length);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_text noargs
static PyObject *
_wrap_gtk_selection_data_get_text(PyObject *self)
{
    guchar *ret;

    ret = gtk_selection_data_get_text(pyg_boxed_get(self, GtkSelectionData));
    if (ret) {
        PyObject *py_ret = PyUnicode_DecodeUTF8(ret, strlen(ret), "strict");
        g_free(ret);
        return py_ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_selection_data_get_targets noargs
static PyObject *
_wrap_gtk_selection_data_get_targets(PyObject *self)
{
    GdkAtom *targets;
    gint n_atoms;

    if (gtk_selection_data_get_targets(pyg_boxed_get(self, GtkSelectionData),
                                       &targets, &n_atoms)) {
        PyObject *ret;
        gint i;

        ret = PyTuple_New(n_atoms);
        for (i = 0; i < n_atoms; i++)
            PyTuple_SetItem(ret, i, PyGdkAtom_New(targets[i]));
        g_free(targets);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_clipboard_set_with_data kwargs
static void
clipboard_get_func(GtkClipboard *clipboard, GtkSelectionData *selection_data,
		   guint info, gpointer user_data)
{
    PyObject *callback, *args, *ret;

    pyg_block_threads();
    callback = PyTuple_GetItem((PyObject *)user_data, 0);
    args = Py_BuildValue("(NNiO)",
			 pygobject_new((GObject *)clipboard),
			 pyg_boxed_new(GTK_TYPE_SELECTION_DATA,
				       selection_data, FALSE, FALSE),
			 info, PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    pyg_unblock_threads();
}
static void
clipboard_clear_func(GtkClipboard *clipboard, gpointer user_data)
{
    PyObject *callback, *args, *ret;

    pyg_block_threads();
    callback = PyTuple_GetItem((PyObject *)user_data, 1);
    args = Py_BuildValue("(NO)",
			 pygobject_new((GObject *)clipboard),
			 PyTuple_GetItem((PyObject *)user_data, 2));
    ret = PyObject_CallObject(callback, args);
    if (!ret)
	PyErr_Print();
    Py_XDECREF(ret);
    Py_DECREF((PyObject *)user_data);
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_clipboard_set_with_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "get_func", "clear_func", "user_data", NULL };
    PyObject *py_targets, *get_func, *clear_func = Py_None, *user_data = Py_None;
    GtkTargetEntry *targets;
    gint n_targets, i;
    gboolean ret;
    PyObject *data, *py_ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO|OO:GtkClipboard.set_with_data",kwlist,
                                     &py_targets, &get_func, &clear_func,
				     &user_data))
        return NULL;
    if (!PyCallable_Check(get_func)) {
	PyErr_SetString(PyExc_TypeError, "get_func must be callable");
	return NULL;
    }
    if (clear_func != Py_None && !PyCallable_Check(clear_func)) {
	PyErr_SetString(PyExc_TypeError,"clear_func must be callable or None");
	return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    data = Py_BuildValue("(OOO)", get_func, clear_func, user_data);
    ret = gtk_clipboard_set_with_data(GTK_CLIPBOARD(self->obj),
				      targets, n_targets,
				      clipboard_get_func, clipboard_clear_func,
				      data);
    g_free(targets);
    Py_DECREF(py_targets);
    if (!ret) {
	Py_DECREF(data);
    }

    py_ret = ret ? Py_True : Py_False;
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gtk_label_get noargs
static PyObject *
_wrap_gtk_label_get(PyGObject *self)
{
    gchar *text = NULL;

    gtk_label_get(GTK_LABEL(self->obj), &text);
    if (text)
        return PyString_FromString(text);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_label_get_selection_bounds noargs
static PyObject *
_wrap_gtk_label_get_selection_bounds(PyGObject *self)
{
    int start, end;

    if (!gtk_label_get_selection_bounds(GTK_LABEL(self->obj), &start, &end)) {
       return Py_BuildValue ("()");
    }

    return Py_BuildValue("(ii)", start, end);
}
%%
override gtk_label_get_layout_offsets noargs
static PyObject *
_wrap_gtk_label_get_layout_offsets(PyGObject *self)
{
    gint x;
    gint y;

    gtk_label_get_layout_offsets(GTK_LABEL(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gtk_spin_button_get_increments noargs
static PyObject *
_wrap_gtk_spin_button_get_increments(PyGObject *self)
{
    gdouble step;
    gdouble page;

    gtk_spin_button_get_increments(GTK_SPIN_BUTTON(self->obj), &step, &page);
    return Py_BuildValue("(dd)", step, page);
}
%%
override gtk_spin_button_get_range noargs
static PyObject *
_wrap_gtk_spin_button_get_range(PyGObject *self)
{
    gdouble min;
    gdouble max;

    gtk_spin_button_get_range(GTK_SPIN_BUTTON(self->obj), &min, &max);
    return Py_BuildValue("(dd)", min, max);
}
%%
override gtk_box_query_child_packing kwargs
static PyObject *
_wrap_gtk_box_query_child_packing(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *pychild;
    GtkWidget *child;
    GList *children;
    gboolean expand, fill;
    guint padding;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!:GtkBox.query_child_packing", kwlist,
                                     &PyGtkWidget_Type, &pychild)) {
        return NULL;
    }

    child = GTK_WIDGET(pychild->obj);
    children = gtk_container_get_children(GTK_CONTAINER(self->obj));
    if (g_list_find(children, child) == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a child");
        return NULL;
    }
    gtk_box_query_child_packing(GTK_BOX(self->obj),
                                child, &expand, &fill,
                                &padding, &pack_type);
    return Py_BuildValue("(iiii)", (int)expand, (int)fill, padding, pack_type);
}
%%
override gtk_combo_set_popdown_strings kwargs
static PyObject *
_wrap_gtk_combo_set_popdown_strings(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "strings", NULL };
    PyObject *list;
    GList *glist = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkCombo.set_popdown_strings", kwlist,
                                     &list))
        return NULL;
    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be a sequence");
        return NULL;
    }
    len = PySequence_Length(list);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(list, i);

        Py_DECREF(item);
        if (!PyString_Check(item) && !PyUnicode_Check(item)) {
            PyErr_SetString(PyExc_TypeError,
                            "sequence item not a string or unicode object");
            g_list_free(glist);
            return NULL;
        }
        glist = g_list_append(glist, PyString_AsString(item));
    }
    gtk_combo_set_popdown_strings(GTK_COMBO(self->obj), glist);
    g_list_free(glist);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_curve_get_vector kwargs
static PyObject *
_wrap_gtk_curve_get_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "size", NULL };
    int size = -1, i;
    gfloat *vector;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|i:GtkCurve.get_vector", kwlist,
                                     &size))
        return NULL;
    if (size < 0) size = GTK_CURVE(self->obj)->num_points;
    vector = g_new(gfloat, size);
    gtk_curve_get_vector(GTK_CURVE(self->obj), size, vector);
    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyFloat_FromDouble(vector[i]));
    g_free(vector);
    return ret;
}
%%
override gtk_curve_set_vector kwargs
static PyObject *
_wrap_gtk_curve_set_vector(PyGObject *self, PyObject *args,
                           PyObject *kwargs)
{
    static char *kwlist[] = { "vector", NULL };
    PyObject *seq;
    int size, i;
    gfloat *vector;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GtkCurve.set_vector",
                                     kwlist, &seq))
        return NULL;
    if (!PySequence_Check(seq)) {
        PyErr_SetString(PyExc_TypeError, "1st argument is not a sequence");
        return NULL;
    }
    size = PySequence_Length(seq);
    vector = g_new(gfloat, size);
    for (i = 0; i < size; i++) {
        PyObject *item = PySequence_GetItem(seq, i);

        Py_DECREF(item);
        item = PyNumber_Float(item); /* item has a ref now */
        if (item == NULL) {
            g_free(vector);
            return NULL;
        }
        vector[i] = PyFloat_AsDouble(item);
        Py_DECREF(item);
    }
    gtk_curve_set_vector(GTK_CURVE(self->obj), size, vector);
    g_free(vector);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_binding_entry_add_signal
static PyObject *
_wrap_gtk_binding_entry_add_signal(PyGObject *self, PyObject *args)
{
    PyObject *first;
    gint len, i;
    PyObject *class;
    guint keyval, modifiers;
    gchar *signal_name;
    GType class_type;
    GtkBindingSet *bset = NULL;
    GSList *slist = NULL;
    gchar *errmsg;

    len = PyTuple_Size(args);
    if (len < 4) {
        PyErr_SetString(PyExc_TypeError, "binding_entry_add_signal requires at"
                        " least 4 arguments");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 4);
    if (!PyArg_ParseTuple(first, "Oiis:binding_entry_add_signal", &class,
                          &keyval, &modifiers, &signal_name)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));

    /* extra args */
    if ((len-4)%2) {
        PyErr_SetString(PyExc_ValueError,
                        "GtkBindingSet.add_signal requires an even number"
                        " of parameter pairs following the first four args");
        return NULL;
    }
    for (i=4; i < len; i+=2) {
        PyObject *item;
        GType arg_type;
        GtkBindingArg *arg = NULL;

        item = PyTuple_GET_ITEM(args, i);
        arg_type = pyg_type_from_object(item);
        if (!arg_type) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "GtkBindingSet.add_signal parameter types"
                            " must be int");
            goto arg_error;
        }
        arg = g_new0 (GtkBindingArg, 1);
        slist = g_slist_prepend(slist, arg);

        arg->arg_type = arg_type;
        switch (GTK_FUNDAMENTAL_TYPE(arg->arg_type)) {
        case GTK_TYPE_CHAR:
        case GTK_TYPE_UCHAR:
        case GTK_TYPE_INT:
        case GTK_TYPE_UINT:
        case GTK_TYPE_BOOL:
        case GTK_TYPE_ENUM:
        case GTK_TYPE_FLAGS:
        case GTK_TYPE_LONG:
        case GTK_TYPE_ULONG:
            arg->arg_type = GTK_TYPE_LONG;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyInt_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be int", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (glong)PyInt_AsLong(item);
            break;
        case GTK_TYPE_FLOAT:
        case GTK_TYPE_DOUBLE:
            arg->arg_type = GTK_TYPE_DOUBLE;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyFloat_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal "
                                         "arg[%u] must be float", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.long_data = (gdouble)PyFloat_AsDouble(item);
            break;
        case GTK_TYPE_STRING:
            arg->arg_type = GTK_TYPE_STRING;
            if (arg->arg_type != GTK_TYPE_IDENTIFIER)
                arg->arg_type = GTK_TYPE_STRING;
            item = PyTuple_GET_ITEM(args, i+1);
            if (!PyString_Check(item)) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            arg->d.string_data = (gchar*)PyString_AsString(item);
            if (!arg->d.string_data) {
                errmsg = g_strdup_printf("GtkBindingSet.add_signal arg[%u] "
                                         "must be non-empty string", i+1);
                PyErr_SetString(PyExc_TypeError, errmsg);
                g_free(errmsg);
                goto arg_error;
            }
            break;
        default:
            errmsg = g_strdup_printf("GtkBindingSet.add_signal unsupported "
                                     "type %10s for arg[%u]",
                                     gtk_type_name(arg->arg_type), i+1);
            PyErr_SetString(PyExc_TypeError, errmsg);
            g_free(errmsg);
            goto arg_error;
        } /* switch */
    }

    slist = g_slist_reverse (slist);
    gtk_binding_entry_add_signall (bset, keyval,modifiers, signal_name, slist);

    g_slist_foreach(slist, (GFunc)g_free, NULL);
    g_slist_free(slist);

    Py_INCREF(Py_None);
    return Py_None;

arg_error:
    if (slist) {
        g_slist_foreach(slist, (GFunc)g_free, NULL);
        g_slist_free(slist);
    }
    return NULL;
}
%%
override gtk_main noargs
static PyObject *
_wrap_gtk_main(PyObject *self)
{
    pyg_unblock_threads();
    gtk_main();
    pyg_block_threads();
    if (PyErr_Occurred())
        return NULL;
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration kwargs
static PyObject *
_wrap_gtk_main_iteration(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;
    PyObject *py_ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration", kwlist,
                                    &block))
        return NULL;
    pyg_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pyg_block_threads();

    py_ret = ret ? Py_True : Py_False;
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gtk_main_quit args
static PyObject *
_wrap_gtk_main_quit(PyObject *self, PyObject *args)
{
    /* args is just ignored, so obj.connect(signal, func) always works */

    /* Sanity check to make sure we're in a mainloop */
    if (gtk_main_level() == 0) {
	PyErr_SetString(PyExc_RuntimeError,
			"called outside of a mainloop");
	return NULL;
    }
	
    gtk_main_quit();
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_main_iteration_do kwargs
static PyObject *
_wrap_gtk_main_iteration_do(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"block", NULL};
    int block = 1, ret;
    PyObject *py_ret;

    if(!PyArg_ParseTupleAndKeywords(args, kwargs, "|i:main_iteration_do",
                                    kwlist, &block))
        return NULL;
    pyg_unblock_threads();
    ret = gtk_main_iteration_do(block);
    pyg_block_threads();

    py_ret = ret ? Py_True : Py_False;
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gtk_quit_add
static gboolean
quit_handler_marshal(gpointer user_data)
{
    PyObject *tuple, *ret;
    gboolean res;

    g_return_val_if_fail(user_data != NULL, FALSE);

    pyg_block_threads();

    tuple = (PyObject *)user_data;
    ret = PyObject_CallObject(PyTuple_GetItem(tuple, 0),
                              PyTuple_GetItem(tuple, 1));
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }
    pyg_unblock_threads();

    return res;
}

static PyObject *
_wrap_gtk_quit_add(PyObject *self, PyObject *args)
{
    gint main_level;
    PyObject *first, *callback, *cbargs = NULL, *data;
    gint len;

    len = PyTuple_Size(args);
    if (len < 2) {
        PyErr_SetString(PyExc_TypeError,
                        "quit_add requires at least 2 args");
        return NULL;
    }
    first = PySequence_GetSlice(args, 0, 2);
    if (!PyArg_ParseTuple(first, "iO:quit_add", &main_level, &callback)) {
        Py_DECREF(first);
        return NULL;
    }
    Py_DECREF(first);
    if (!PyCallable_Check(callback)) {
        PyErr_SetString(PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    cbargs = PySequence_GetSlice(args, 2, len);
    if (cbargs == NULL)
      return NULL;

    data = Py_BuildValue("(ON)", callback, cbargs);
    if (data == NULL)
      return NULL;
    return PyInt_FromLong(gtk_quit_add_full(main_level, quit_handler_marshal,
                                            NULL, data, pyg_destroy_notify));
}
%%
override gtk_editable_insert_text kwargs
static PyObject *
_wrap_gtk_editable_insert_text(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "position", NULL };
    char *text;
    int len, position=0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GtkEditable.insert_text",
                                     kwlist, &text, &len, &position))
        return NULL;
    gtk_editable_insert_text(GTK_EDITABLE(self->obj), text, len, &position);
    return PyInt_FromLong(position);
}
%%
override gtk_editable_get_selection_bounds noargs
static PyObject *
_wrap_gtk_editable_get_selection_bounds(PyGObject *self, PyObject *args)
{
    int start, end;

    if (!gtk_editable_get_selection_bounds(GTK_EDITABLE(self->obj), &start, &end)) {
            return Py_BuildValue ("()");
    }

    return Py_BuildValue ("(ii)", start, end);
}
%%
override gtk_entry_get_layout_offsets noargs
static PyObject *
_wrap_gtk_entry_get_layout_offsets(PyGObject *self, PyObject *args)
{
    int x, y;

    gtk_entry_get_layout_offsets(GTK_ENTRY(self->obj), &x, &y);

    return Py_BuildValue ("(ii)", x, y);
}
%%
override gtk_item_factory_create_items kwargs
static void
pygtk_item_factory_cb(PyGtkCustomNotify *cunote,
                      guint action, GtkWidget *widget)
{
    PyObject *ret;

    pyg_block_threads();
    if (cunote->data)
        ret = PyObject_CallFunction(cunote->func, "OiO", cunote->data, action,
                                    pygobject_new((GObject *)widget));
    else
        ret = PyObject_CallFunction(cunote->func, "iO", action,
                                    pygobject_new((GObject *)widget));
    if (ret == NULL) {
        PyErr_Print();
    } else
        Py_DECREF(ret);
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_item_factory_create_items(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyObject *list, *cb, *cbdata = NULL;
    GtkItemFactoryEntry ent;
    PyObject *extra_data = NULL;
    GtkItemFactory *ifact;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GtkItemFactory.create_items", kwlist,
                                     &list, &cbdata))
        return NULL;

    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "entries must be a sequence");
        return NULL;
    }

    ifact = GTK_ITEM_FACTORY(self->obj);
    len = PySequence_Size(list);
    for (i = 0; i < len; i++) {
        PyGtkCustomNotify *cunote = NULL;
        PyObject *item = PySequence_GetItem(list, i);
        Py_DECREF(item);

        memset(&ent, 0, sizeof(ent));
        cb = Py_None;

        if (!PyArg_ParseTuple(item, "s|zOizO", &(ent.path), &(ent.accelerator),
                              &cb, &(ent.callback_action), &(ent.item_type),
                              &extra_data)) {
            return NULL;
        }

        if (cb == Py_None) {
            ent.callback = NULL;
        } else {
            ent.callback = (GtkItemFactoryCallback)pygtk_item_factory_cb;
            cunote = g_new0(PyGtkCustomNotify, 1);
            cunote->func = cb;
            cunote->data = cbdata;
            Py_XINCREF(cunote->func);
            Py_XINCREF(cunote->data);
        }

        if (extra_data != NULL) {
            if (PyString_Check(extra_data)) {
                ent.extra_data = PyString_AsString(extra_data);
            } else if (pygobject_check(extra_data, &PyGdkPixbuf_Type)) {
		/* create_items actually expects inline image data 
		 * so let's create it for the user from the pixbuf
		 * it's not optimal but it's convenient
		 */  
		GdkPixdata pixdata; 
		GdkPixbuf * pixbuf;
		guint8 * serialstr;
		guint len;
		
		pixbuf = GDK_PIXBUF(pygobject_get(extra_data));
		gdk_pixdata_from_pixbuf(&pixdata, pixbuf, FALSE);
		serialstr = gdk_pixdata_serialize(&pixdata, &len);
                ent.extra_data = serialstr;
            } else {
                PyErr_SetString(PyExc_TypeError,
                                "last argument must be a GdkPixBuf or a string");
                return NULL;
            }
        }
        if (cunote != NULL) {
            pyg_block_threads();
            g_object_weak_ref(G_OBJECT(ifact),
                              (GWeakNotify) pygtk_custom_destroy_notify,
                              cunote);
            pyg_unblock_threads();
        }

        gtk_item_factory_create_item(ifact, &ent, cunote, 1);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_menu_popup kwargs
static void
pygtk_menu_position(GtkMenu *menu, int *x, int *y, gboolean *push_in,
                    PyObject *func)
{
    PyObject *ret;

    pyg_block_threads();
    ret = PyObject_CallFunction(func, "O", pygobject_new((GObject *)menu));
    if (ret == NULL || !PyArg_ParseTuple(ret, "iii", x, y, push_in)) {
        PyErr_Print();
        Py_XDECREF(ret);
    } else {
        Py_DECREF(ret);
    }
    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_popup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent_menu_shell", "parent_menu_item", "func",
                       "button", "activate_time", NULL };
    PyGObject *py_pms, *py_pmi;
    GtkWidget *pms = NULL, *pmi = NULL;
    PyObject *func;
    int button;
    guint32 time;
    PyObject *pytime;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,  "OOOiO:GtkMenu.popup",
                                     kwlist, &py_pms, &py_pmi, &func,
                                     &button, &pytime))
        return NULL;
    if (pygobject_check(py_pms, &PyGtkWidget_Type))
        pms = GTK_WIDGET(py_pms->obj);
    else if ((PyObject *)py_pms != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_pmi, &PyGtkWidget_Type))
        pmi = GTK_WIDGET(py_pmi->obj);
    else if ((PyObject *)py_pmi != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (!PyCallable_Check(func) && func != Py_None) {
        PyErr_SetString(PyExc_TypeError, "third argument not callable");
        return NULL;
    }
    if (PyLong_Check(pytime)) {
	time = PyLong_AsUnsignedLong(pytime);
	if (PyErr_Occurred())
	    return NULL;
    } else if (PyInt_Check(pytime)) {
	time = PyInt_AsLong(pytime);
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "last argument must be int or long");
        return NULL;
    }
    if (func != Py_None) {
        Py_INCREF(func);
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi,
                       (GtkMenuPositionFunc)pygtk_menu_position,
                       func, button, time);
    } else
        gtk_menu_popup(GTK_MENU(self->obj), pms, pmi, NULL,NULL, button,time);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_pixmap_get noargs
static PyObject *
_wrap_gtk_pixmap_get(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    gtk_pixmap_get(GTK_PIXMAP(self->obj), &pixmap, &mask);
    return Py_BuildValue("(NN)", pygobject_new((GObject *)pixmap),
                         pygobject_new((GObject *)mask));
}

%%
override gtk_button_new kwargs
static int
_wrap_gtk_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", "stock", NULL };
    gchar *text = NULL, *stock = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|zz:GtkButton.__init__",
                                     kwlist, &text, &stock))
        return -1;
    if (stock)
        self->obj = (GObject *)gtk_button_new_from_stock(stock);
    else if (text)
        self->obj = (GObject *)gtk_button_new_with_mnemonic(text);
    else
        self->obj = (GObject *)gtk_button_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_button_box_get_child_size noargs
static PyObject *
_wrap_gtk_button_box_get_child_size(PyGObject *self)
{
    gint min_width;
    gint min_height;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_size(GTK_BUTTON_BOX(self->obj), &min_width, &min_height);
    return Py_BuildValue("(ii)", min_width, min_height);
}
%%
override gtk_button_box_get_child_ipadding noargs
static PyObject *
_wrap_gtk_button_box_get_child_ipadding(PyGObject *self)
{
    gint ipad_x;
    gint ipad_y;

    if (PyErr_Warn(PyExc_DeprecationWarning, "don't use this") < 0)
        return NULL;
    gtk_button_box_get_child_ipadding(GTK_BUTTON_BOX(self->obj), &ipad_x, &ipad_y);
    return Py_BuildValue("(ii)", ipad_x, ipad_y);
}
%%
override gtk_toggle_button_new kwargs
static int
_wrap_gtk_toggle_button_new(PyGObject *self, PyObject*args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkToggleButton.__init__", kwlist,
                                     &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_toggle_button_new_with_mnemonic(text);
    else
        self->obj = (GObject *)gtk_toggle_button_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkToggleButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_check_button_new kwargs
static int
_wrap_gtk_check_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"|z:GtkCheckButton.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_check_button_new_with_mnemonic(text);
    else
        self->obj = (GObject *)gtk_check_button_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_new kwargs
static int
_wrap_gtk_radio_button_new(PyGObject *self, PyObject *args, PyObject*kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    PyObject *py_group = Py_None;
    gchar *label = NULL;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"|Oz:GtkRadioButton.__init__",
                                     kwlist, &py_group, &label))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioButton_Type))
        group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioButton or None");
        return -1;
    }
    /* various configs for create radio buttons ... */
    if (label == NULL) {
        if (group == NULL)
            self->obj = (GObject *)gtk_radio_button_new(NULL);
        else
            self->obj = (GObject *)gtk_radio_button_new_from_widget(group);
    } else {
        if (group == NULL)
            self->obj = (GObject *)gtk_radio_button_new_with_mnemonic(NULL,label);
        else
            self->obj = (GObject *)gtk_radio_button_new_with_mnemonic_from_widget
                (group, label);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioButton object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_button_get_group noargs
static PyObject *
_wrap_gtk_radio_button_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O!:GtkRadioButton.set_group",
                                     kwlist, &PyGtkRadioButton_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    list = gtk_radio_button_get_group(group);
    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_item_new kwargs
static int
_wrap_gtk_list_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkListItem.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_list_item_new_with_label(text);
    else
        self->obj = (GObject *)gtk_list_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkListItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_item_new kwargs
static int
_wrap_gtk_menu_item_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|z:GtkMenuItem.__init__",
                                     kwlist, &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_menu_item_new_with_mnemonic(text);
    else
        self->obj = (GObject *)gtk_menu_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_menu_attach_to_widget kwargs
static void
pygtk_menu_detach (GtkWidget *attach_widget, GtkMenu *menu)
{
    PyObject *func;
    PyObject *ret;

    func = g_object_get_data (G_OBJECT (menu), "pygtk_menu_detach_func");

    if (!func)
        return;

    pyg_block_threads();

    ret = PyObject_CallFunction (func, "OO",
                                 pygobject_new ((GObject *) menu),
                                 pygobject_new ((GObject *) attach_widget));
    if (ret == NULL) {
        PyErr_Print ();
        Py_XDECREF (ret);
    }
    else
        Py_DECREF (ret);

    pyg_unblock_threads();
}
static PyObject *
_wrap_gtk_menu_attach_to_widget (PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "attach_widget", "detach_func", NULL };
    PyGObject *py_attach_widget;
    PyObject *detach_func;
    GtkWidget *attach_widget;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "O!O:GtkMenu.attach_to_widget",
                                      kwlist, &PyGtkWidget_Type,
                                      &py_attach_widget, &detach_func))
        return NULL;

    attach_widget = GTK_WIDGET (py_attach_widget->obj);

    if (!PyCallable_Check (detach_func) && detach_func != Py_None) {
        PyErr_SetString (PyExc_TypeError, "second argument not callable");
        return NULL;
    }

    if (detach_func != Py_None) {
        Py_INCREF (detach_func);
        g_object_set_data_full (self->obj,
                                "pygtk_menu_detach_func",
                                detach_func,
                                pyg_destroy_notify);
    }
    else
        g_object_set_data (self->obj, "pygtk_menu_detach_func", NULL);

    gtk_menu_attach_to_widget (GTK_MENU (self->obj), attach_widget,
                               (GtkMenuDetachFunc) pygtk_menu_detach);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override gtk_check_menu_item_new kwargs
static int
_wrap_gtk_check_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "label", NULL };
    gchar *text = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|z:GtkCheckMenuItem.__init__", kwlist,
                                     &text))
        return -1;
    if (text)
        self->obj = (GObject *)gtk_check_menu_item_new_with_mnemonic(text);
    else
        self->obj = (GObject *)gtk_check_menu_item_new();
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkCheckMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_radio_menu_item_new kwargs
static int
_wrap_gtk_radio_menu_item_new(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "group", "label", NULL };
    gchar *text = NULL;
    PyObject *py_group = Py_None;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|Oz:GtkRadioMenuItem.__init__", kwlist,
                                     &py_group, &text))
        return -1;
    if (py_group == Py_None)
        group = NULL;
    else if (pygobject_check(py_group, &PyGtkRadioMenuItem_Type))
        group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    else {
        PyErr_SetString(PyExc_TypeError,
                        "first argument must be a GtkRadioMenuItem or None");
        return -1;
    }
    /* various configs for create radio buttons ... */
    if (text == NULL) {
        if (group == NULL)
            self->obj = (GObject *)gtk_radio_menu_item_new(NULL);
        else
            self->obj = (GObject *)gtk_radio_menu_item_new(group->group);
    } else {
        if (group == NULL)
            self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic(NULL,
                                                                         text);
        else
            self->obj = (GObject *)gtk_radio_menu_item_new_with_mnemonic
                (group->group, text);
    }
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkRadioMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_image_menu_item_new kwargs
static int
_wrap_gtk_image_menu_item_new(PyGObject *self, PyObject *args,PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "accel_group", NULL };
    gchar *stock_id = NULL;
    PyObject *py_accel_group = Py_None;
    GtkAccelGroup *accel_group= NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|zO:GtkImageMenuItem.__init__",kwlist,
                                     &stock_id, &py_accel_group))
        return -1;
    if (pygobject_check(py_accel_group, &PyGtkAccelGroup_Type))
        accel_group = GTK_ACCEL_GROUP(pygobject_get(py_accel_group));

    if (stock_id)
        self->obj = (GObject *)gtk_image_menu_item_new_from_stock(stock_id,
                                                                  accel_group);
    else
        self->obj = (GObject *)gtk_image_menu_item_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkImageMenuItem object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override-slot GtkRequisition.tp_as_sequence
static int
_wrap_gtk_requisition_length(PyGBoxed *self)
{
    return 2;
}
static PyObject *
_wrap_gtk_requisition_getitem(PyGBoxed *self, int pos)
{
    GtkRequisition *requisition;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    switch (pos) {
    case 0: return PyInt_FromLong(requisition->width);
    case 1: return PyInt_FromLong(requisition->height);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gtk_requisition_setitem(PyGBoxed *self, int pos, PyObject *value)
{
    GtkRequisition *requisition;
    gint val;

    if (pos < 0) pos += 2;
    if (pos < 0 || pos >= 2) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    requisition = pyg_boxed_get(self, GtkRequisition);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: requisition->width      = val; break;
    case 1: requisition->height     = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gtk_requisition_tp_as_sequence = {
    (inquiry)_wrap_gtk_requisition_length,
    (binaryfunc)0,
    (intargfunc)0,
    (intargfunc)_wrap_gtk_requisition_getitem,
    (intintargfunc)0,
    (intobjargproc)_wrap_gtk_requisition_setitem,
    (intintobjargproc)0
};
%%
override-attr GtkRequisition.width
static int
_wrap_gtk_requisition__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->width = val;
    return 0;
}
%%
override-attr GtkRequisition.height
static int
_wrap_gtk_requisition__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GtkRequisition)->height = val;
    return 0;
}
%%
override gtk_toolbar_append_item kwargs
static PyObject *
_wrap_gtk_toolbar_append_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param = NULL, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOO|O:GtkToolbar.append_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_item kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_item(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOO:GtkToolbar.prepend_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_item kwargs
static PyObject *
_wrap_gtk_toolbar_insert_item(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "text", "tooltip_text", "tooltip_private_text",
                              "icon", "callback", "user_data", "position",
                              NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyGObject *py_icon;
    PyObject *callback, *param, *py_ret;
    GtkWidget *icon = NULL, *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOOi:GtkToolbar.insert_item", kwlist,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "forth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_item(GTK_TOOLBAR(self->obj), text, tooltip_text,
                                  tooltip_private_text, icon, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_stock kwargs
static PyObject *
_wrap_gtk_toolbar_insert_stock(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "stock_id", "tooltip_text", "tooltip_private_text",
                              "callback", "user_data", "position",
                              NULL };
    char *stock_id, *tooltip_text, *tooltip_private_text;
    PyObject *callback, *param, *py_ret;
    GtkWidget *ret;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zzzOOi:GtkToolbar.insert_stock", kwlist,
                                     &stock_id, &tooltip_text,
                                     &tooltip_private_text,
                                     &callback, &param, &position))
        return NULL;

    ret = gtk_toolbar_insert_stock(GTK_TOOLBAR(self->obj), stock_id, tooltip_text,
                                  tooltip_private_text, NULL, NULL,
                                  position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_append_element kwargs
static PyObject *
_wrap_gtk_toolbar_append_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.append_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_append_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_prepend_element kwargs
static PyObject *
_wrap_gtk_toolbar_prepend_element(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOO:GtkToolbar.prepend_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_prepend_element(GTK_TOOLBAR(self->obj), type, widget,
                                      text, tooltip_text, tooltip_private_text,
                                      icon, NULL, NULL);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_toolbar_insert_element kwargs
static PyObject *
_wrap_gtk_toolbar_insert_element(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "type", "widget", "text", "tooltip_text",
                              "tooltip_private_text", "icon", "callback",
                              "user_data", "position", NULL };
    char *text, *tooltip_text, *tooltip_private_text;
    PyObject *py_type, *callback, *param, *py_ret;
    PyGObject *py_widget, *py_icon;
    GtkWidget *widget = NULL, *icon = NULL, *ret;
    GtkToolbarChildType type;
    int position;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOzzzOOOi:GtkToolbar.insert_element",
                                     kwlist,
                                     &py_type, &py_widget,
                                     &text, &tooltip_text,
                                     &tooltip_private_text, &py_icon,
                                     &callback, &param, &position))
        return NULL;
    if (pyg_enum_get_value(GTK_TYPE_TOOLBAR_CHILD_TYPE,
                           py_type, (gint *)&type))
        return NULL;
    if (pygobject_check(py_widget, &PyGtkWidget_Type))
        widget = GTK_WIDGET(py_widget->obj);
    else if ((PyObject *)py_widget != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "second argument must be a GtkWidget or None");
        return NULL;
    }
    if (pygobject_check(py_icon, &PyGtkWidget_Type))
        icon = GTK_WIDGET(py_icon->obj);
    else if ((PyObject *)py_icon != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "sixth argument must be a GtkWidget or None");
        return NULL;
    }
    ret = gtk_toolbar_insert_element(GTK_TOOLBAR(self->obj), type, widget,
                                     text, tooltip_text, tooltip_private_text,
                                     icon, NULL, NULL, position);
    py_ret = pygobject_new((GObject *)ret);
    if (ret && PyCallable_Check(callback) &&
        (type == GTK_TOOLBAR_CHILD_BUTTON ||
         type == GTK_TOOLBAR_CHILD_TOGGLEBUTTON ||
         type == GTK_TOOLBAR_CHILD_RADIOBUTTON)) {
        GClosure *closure;

        closure = pyg_closure_new(callback, param, NULL);
        g_signal_connect_closure(ret, "clicked", closure, FALSE);
        pygobject_watch_closure(py_ret, closure);
    }
    return py_ret;
}
%%
override gtk_notebook_query_tab_label_packing kwargs
static PyObject *
_wrap_gtk_notebook_query_tab_label_packing(PyGObject *self, PyObject *args,
                                           PyObject *kwargs)
{
    static char *kwlist[] = { "child", NULL };
    PyGObject *child;
    gboolean expand, fill;
    GtkPackType pack_type;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkNotebook.query_tab_label_packing",
                                     kwlist, &child))
        return NULL;
    if (!pygobject_check(child, &PyGtkWidget_Type)) {
        PyErr_SetString(PyExc_TypeError, "child must be a GtkWidget");
        return NULL;
    }
    gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(self->obj),
                                         GTK_WIDGET(child->obj),
                                         &expand, &fill, &pack_type);
    return Py_BuildValue("(iii)", expand, fill, pack_type);
}
%%
override gtk_list_insert_items kwargs
static PyObject *
_wrap_gtk_list_insert_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", "position", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int position, len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!i:GtkList.insert_items",
                                     kwlist, &PyList_Type, &py_items,
                                     &position))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_insert_items(GTK_LIST(self->obj), items, position);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_append_items kwargs
static PyObject *
_wrap_gtk_list_append_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.append_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_append_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_prepend_items kwargs
static PyObject *
_wrap_gtk_list_prepend_items(PyGObject *self, PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.preppend_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_prepend_items(GTK_LIST(self->obj), items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_list_remove_items kwargs
static PyObject *
_wrap_gtk_list_remove_items(PyGObject *self, PyObject *args,
                            PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    GList *items = NULL;
    int len, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:GtkList.remove_items",
                                     kwlist, &PyList_Type, &py_items))
        return NULL;
    len = PyList_Size(py_items);
    for (i = 0; i < len; i++) {
        PyObject *item = PyList_GetItem(py_items, i);
        if (!pygobject_check(item, &PyGtkListItem_Type)) {
            PyErr_SetString(PyExc_TypeError, "list item not a GtkListItem");
            g_list_free(items);
            return NULL;
        }
        items = g_list_append(items, pygobject_get(item));
    }
    gtk_list_remove_items(GTK_LIST(self->obj), items);
    g_list_free(items);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkList.selection
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure)
{
    GList *selection;
    PyObject *item, *ret = PyList_New(0);

    if (ret == NULL)
        return NULL;

    for (selection = GTK_LIST(self->obj)->selection; selection != NULL;
         selection = selection->next) {
        item = pygobject_new((GObject *) GTK_LIST_ITEM(selection->data));

        if (!item) {
            Py_DECREF(ret);
            return NULL;
        }

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    return ret;
}
%%
override gtk_list_get_selection noargs
static PyObject *
_wrap_gtk_list__get_selection(PyGObject *self, void *closure);
static PyObject *
_wrap_gtk_list_get_selection(PyGObject *self)
{
    return _wrap_gtk_list__get_selection(self, NULL);
}
%%
override gtk_color_selection_get_current_color noargs
static PyObject *
_wrap_gtk_color_selection_get_current_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_current_color(GTK_COLOR_SELECTION(self->obj),
                                          &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_color_selection_get_previous_color noargs
static PyObject *
_wrap_gtk_color_selection_get_previous_color(PyGObject *self)
{
    GdkColor colour = { 0, };

    gtk_color_selection_get_previous_color(GTK_COLOR_SELECTION(self->obj),
                                           &colour);
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gtk_calendar_get_date noargs
static PyObject *
_wrap_gtk_calendar_get_date(PyGObject *self)
{
    guint year, month, day;

    gtk_calendar_get_date(GTK_CALENDAR(self->obj), &year, &month, &day);
    return Py_BuildValue("(iii)", year, month, day);
}
%%
override gtk_drag_dest_set kwargs
static PyObject *
_wrap_gtk_drag_dest_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "flags", "targets", "actions", NULL };
    PyObject *py_flags, *py_targets, *py_actions;
    GtkDestDefaults flags;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_dest_set", kwlist,
                                     &py_flags, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_DEST_DEFAULTS, py_flags, (gint *)&flags))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a sequence");
        return NULL;
    }
    n_targets = PySequence_Length(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
            return NULL;
        }
    }
    gtk_drag_dest_set(GTK_WIDGET(self->obj), flags, targets, n_targets,
                      actions);
    g_free(targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_dest_find_target kwargs
static PyObject *
_wrap_gtk_drag_dest_find_target(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "context", "target_list", NULL };
    PyObject *context, *py_targets;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;
    GdkAtom atom;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GtkWidget.drag_dest_find_target",
                                     kwlist, &PyGdkDragContext_Type, &context,
                                     &py_targets))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    atom = gtk_drag_dest_find_target(GTK_WIDGET(self->obj),
                                     GDK_DRAG_CONTEXT(pygobject_get(context)),
                                     target_list);
    gtk_target_list_unref(target_list);
    Py_DECREF(py_targets);

    return PyGdkAtom_New(atom);
}
%%
override gtk_drag_dest_get_target_list noargs
static PyObject *
_wrap_gtk_drag_dest_get_target_list(PyGObject *self)
{
    GtkTargetList *target_list;
    PyObject *ret;
    GList *tmp;

    target_list = gtk_drag_dest_get_target_list(GTK_WIDGET(self->obj));

    if (!target_list) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    ret = PyList_New(0);
    for (tmp = target_list->list; tmp != NULL; tmp = tmp->next) {
        GtkTargetPair *pair = tmp->data;
        PyObject *item;

        item = Py_BuildValue("(Nii)", PyGdkAtom_New(pair->target),
                             pair->flags, pair->info);
        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    gtk_target_list_unref(target_list);
    return ret;
}
%%
override gtk_drag_dest_set_target_list kwargs
static PyObject *
_wrap_gtk_drag_dest_set_target_list(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "target_list", NULL };
    PyObject *py_targets;
    gint i, n_targets;
    GtkTargetEntry *targets;
    GtkTargetList *target_list;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkWidget.drag_dest_set_target_list",
                                     kwlist, &py_targets))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    target_list = gtk_target_list_new(targets, n_targets);
    g_free(targets);

    gtk_drag_dest_set_target_list(GTK_WIDGET(self->obj), target_list);
    gtk_target_list_unref(target_list);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_source_set kwargs
static PyObject *
_wrap_gtk_drag_source_set(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "start_button_mask", "targets", "actions", NULL };
    PyObject *py_sbmask, *py_targets, *py_actions;
    GdkModifierType sbmask;
    GtkTargetEntry *targets;
    GdkDragAction actions;
    gint n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOO:GtkWidget.drag_source_set", kwlist,
                                     &py_sbmask, &py_targets, &py_actions))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE,
                             py_sbmask, (gint *)&sbmask))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_drag_source_set(GTK_WIDGET(self->obj), sbmask, targets, n_targets,
                        actions);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_drag_begin kwargs
static PyObject *
_wrap_gtk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", "actions", "button", "event", NULL };
    PyObject *py_targets, *py_actions, *event;
    GtkTargetEntry *tents;
    GtkTargetList *targets;
    GdkDragAction actions;
    gint button, n_targets, i;
    GdkDragContext *context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOiO:GtkWidget.drag_begin", kwlist,
                                     &py_targets, &py_actions, &button,
                                     &event))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_DRAG_ACTION,
                             py_actions, (gint *)&actions))
        return NULL;
    if (!pyg_boxed_check(event, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "event must be a GdkEvent");
        return NULL;
    }
    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    tents = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &tents[i].target,
                              &tents[i].flags, &tents[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(tents);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    targets = gtk_target_list_new(tents, n_targets);
    g_free(tents);
    context = gtk_drag_begin(GTK_WIDGET(self->obj), targets, actions, button,
                             pyg_boxed_get(event, GdkEvent));
    gtk_target_list_unref(targets);
    Py_DECREF(py_targets);
    return pygobject_new((GObject *)context);
}
%%
override gtk_selection_add_targets kwargs
static PyObject *
_wrap_gtk_selection_add_targets(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    static char *kwlist[] = { "selection", "targets", NULL };
    PyObject *py_targets, *py_selection;
    GtkTargetEntry *targets;
    GdkAtom selection;
    int n_targets, i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:GtkWidget.selection_add_targets",
                                     kwlist, &py_selection, &py_targets))
        return NULL;
    selection = pygdk_atom_from_pyobject(py_selection);
    if (PyErr_Occurred())
        return NULL;

    if (!(py_targets = PySequence_Fast(py_targets, "targets must be a sequence")))
	return NULL;
    n_targets = PySequence_Fast_GET_SIZE(py_targets);
    targets = g_new(GtkTargetEntry, n_targets);
    for (i = 0; i < n_targets; i++) {
        PyObject *item = PySequence_Fast_GET_ITEM(py_targets, i);
        if (!PyArg_ParseTuple(item, "zii", &targets[i].target,
                              &targets[i].flags, &targets[i].info)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "list items should be of form (string,int,int)");
            g_free(targets);
	    Py_DECREF(py_targets);
            return NULL;
        }
    }
    gtk_selection_add_targets(GTK_WIDGET(self->obj), selection,
                              targets, n_targets);
    g_free(targets);
    Py_DECREF(py_targets);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_text_child_anchor_get_widgets noargs
static PyObject *
_wrap_gtk_text_child_anchor_get_widgets(PyGObject *self)
{
    GList *list, *tmp;
    PyObject *ret;

    list = gtk_text_child_anchor_get_widgets(GTK_TEXT_CHILD_ANCHOR(self->obj));

    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        GtkWidget *widget = tmp->data;
        PyObject *item = pygobject_new((GObject *)widget);

        PyList_Append(ret, item);
        Py_DECREF(item);
    }
    g_list_free(list);
    return ret;
}
%%
override gtk_dialog_new_with_buttons kwargs
static int
_wrap_gtk_dialog_new_with_buttons(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    gchar *title = NULL;
    PyGObject *py_window = NULL;
    PyObject *py_buttons = Py_None;
    GtkDialogFlags flags = 0;
    int len, i;

    static char *kwlist[] = { "title", "parent", "flags", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|sOiO!:GtkDialog.__init__", kwlist,
                                     &title, &py_window, &flags,
                                     &PyTuple_Type, &py_buttons))
        return -1;

    if (py_window != NULL && py_window != (PyGObject *) Py_None
        && !pygobject_check(py_window, &PyGtkWindow_Type)) {
        PyErr_SetString(PyExc_TypeError, "window must be a GtkWindow or None");
        return -1;
    }

    if (py_buttons != Py_None)
        len = PyTuple_Size(py_buttons);
    else
        len = 0;

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    self->obj = (GObject *)
        gtk_dialog_new_with_buttons(title,
                                    (py_window && py_window != (PyGObject *) Py_None) ? GTK_WINDOW(py_window->obj) : NULL,
                                    flags, NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create GtkDialog object");
        return -1;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }
        gtk_dialog_add_button(GTK_DIALOG(self->obj), PyString_AsString(text),
                              PyInt_AsLong(id));
    }
    pyg_block_threads();
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pyg_unblock_threads();
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_dialog_run noargs
static PyObject *
_wrap_gtk_dialog_run(PyGObject *self)
{
    gint retval;

    pyg_unblock_threads();
    retval = gtk_dialog_run(GTK_DIALOG(self->obj));
    pyg_block_threads();

    return PyInt_FromLong(retval);
}
%%
override gtk_dialog_add_buttons
static PyObject *
_wrap_gtk_dialog_add_buttons(PyGObject *self, PyObject *args)
{
    GtkDialog *dialog;
    int i, len;

    dialog = GTK_DIALOG(self->obj);

    len = PyTuple_Size(args);
    if (len % 2 != 0) {
	PyErr_SetString(PyExc_TypeError,
			"must pass an even number of arguments");
	return NULL;
    }
    for (i = 0; i < len; i+= 2) {
	PyObject *py_text = PyTuple_GetItem(args, i);
	PyObject *py_resp = PyTuple_GetItem(args, i + 1);
	gchar *text;
	gint resp;

	text = PyString_AsString(py_text);
	if (!text) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "button texts must be strings");
	    return NULL;
	}
	resp = PyInt_AsLong(py_resp);
	if (!resp) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "button response codes must be integers");
	    return NULL;
	}
	gtk_dialog_add_button(dialog, text, resp);
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_message_dialog_new kwargs
static int
_wrap_gtk_message_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkButtonsType buttons = GTK_BUTTONS_NONE;
    static char *kwlist[] = { "parent", "flags", "type", "buttons", "message_format", NULL };
    PyObject *py_flags = NULL, *py_type = NULL, *py_buttons = NULL;
    GtkDialogFlags flags = 0;
    GtkWindow *parent = NULL;
    GtkMessageType type = GTK_MESSAGE_INFO;
    PyGObject *py_parent = NULL;
    char *message_format = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|OOOOz:GtkMessageDialog.__init__", kwlist, &py_parent, &py_flags, &py_type, &py_buttons, &message_format))
        return -1;
    if ((PyObject *)py_parent == Py_None)
        parent = NULL;
    else if (py_parent && pygobject_check(py_parent, &PyGtkWindow_Type))
        parent = GTK_WINDOW(py_parent->obj);
    else if (py_parent) {
        PyErr_SetString(PyExc_TypeError, "parent should be a GtkWindow or None");
        return -1;
    }
    if (pyg_enum_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_MESSAGE_TYPE, py_type, (gint *)&type))
        return -1;
    if (pyg_enum_get_value(GTK_TYPE_BUTTONS_TYPE, py_buttons, (gint *)&buttons))
        return -1;

    self->obj = (GObject *)gtk_message_dialog_new(parent, flags, type, buttons, "%s", message_format);
    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkMessageDialog object");
        return -1;
    }
    pyg_block_threads();
    g_object_ref(self->obj); /* we don't own the first reference of windows */
    pyg_unblock_threads();
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gtk_progress_bar_new_with_adjustment kwargs
static PyObject *
_wrap_gtk_progress_bar_new_with_adjustment(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    GtkAdjustment *adjustment = NULL;
    static char *kwlist[] = { "adjustment", NULL };
    PyGObject *py_adjustment = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkProgressBar.__init__", kwlist, &py_adjustment))
        return NULL;
    if ((PyObject *)py_adjustment == Py_None)
        adjustment = NULL;
    else if (py_adjustment && pygobject_check(py_adjustment, &PyGtkAdjustment_Type))
        adjustment = GTK_ADJUSTMENT(py_adjustment->obj);
    else if (py_adjustment) {
        PyErr_SetString(PyExc_TypeError, "adjustment should be a GtkAdjustment or None");
        return NULL;
    }

    if (adjustment)
        self->obj = (GObject *)gtk_progress_bar_new_with_adjustment(adjustment);
    else
        self->obj = (GObject *)gtk_progress_bar_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkProgressBar object");
        return NULL;
    }
    pygobject_register_wrapper((PyObject *)self);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_set_default_files kwargs
static PyObject *
_wrap_gtk_rc_set_default_files(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gchar **filenames = NULL;
    static char *kwlist[] = { "filenames", NULL };
    PyObject *py_filenames = NULL;
    int i, n_files;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:rc_set_default_files",
                                     kwlist, &py_filenames))
        return NULL;

    if (!PySequence_Check(py_filenames)) {
        PyErr_SetString(PyExc_TypeError, "filenames must be a sequence");
        return NULL;
    }

    n_files = PySequence_Length(py_filenames);
    filenames = g_new(gchar *, n_files + 1);
    for (i = 0; i < n_files; i++) {
        PyObject *item = PySequence_GetItem(py_filenames, i);
        Py_DECREF(item); /* PySequence_GetItem INCREF's */
        filenames[i] = PyString_AsString(item);
    }
    filenames[n_files] = NULL;

    gtk_rc_set_default_files(filenames);

    g_free(filenames);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_rc_get_default_files noargs
static PyObject *
_wrap_gtk_rc_get_default_files(PyGObject *self)
{
    gchar **filenames = NULL, **tmp;
    int i = 0, j;
    PyObject *ret;

    filenames = gtk_rc_get_default_files();

    tmp = filenames;
    while (*tmp)
        tmp++, i++;

    ret = PyTuple_New(i);
    for (j = 0; j < i; j++)
        PyTuple_SetItem(ret, j, PyString_FromString(filenames[j]));

    return ret;
}
%%
override gtk_icon_set_new_from_pixbuf kwargs
static int
_wrap_gtk_icon_set_new_from_pixbuf(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixbuf", NULL };
    PyGObject *pixbuf = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GtkIconSet.__init__", kwlist, &pixbuf))
        return -1;
    if (pixbuf && !pygobject_check(pixbuf, &PyGdkPixbuf_Type)) {
        PyErr_SetString(PyExc_TypeError, "pixbuf should be a GdkPixbuf");
        return -1;
    }
    self->gtype = GTK_TYPE_ICON_SET;
    self->free_on_dealloc = FALSE;
    if (pixbuf)
        self->boxed = gtk_icon_set_new_from_pixbuf(GDK_PIXBUF(pixbuf->obj));
    else
        self->boxed = gtk_icon_set_new();

    if (!self->boxed) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GtkIconSet object");
        return -1;
    }
    self->free_on_dealloc = TRUE;
    return 0;
}
%%
override gtk_icon_set_get_sizes noargs
static PyObject *
_wrap_gtk_icon_set_get_sizes(PyGObject *self)
{
    GtkIconSize *sizes;
    int i, n_sizes;
    PyObject *ret;

    gtk_icon_set_get_sizes(pyg_boxed_get(self, GtkIconSet), &sizes, &n_sizes);

    ret = PyTuple_New(n_sizes);
    for (i = 0; i < n_sizes; i++)
        PyTuple_SetItem(ret, i, PyInt_FromLong(sizes[i]));
    g_free(sizes);

    return ret;
}
%%
override gtk_stock_add kwargs
static PyObject *
_wrap_gtk_stock_add(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "items", NULL };
    PyObject *py_items;
    PyObject *py_item;
    GtkStockItem *items = NULL;
    int i, len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:stock_add", kwlist,
                                     &py_items))
        return NULL;

    if (!PySequence_Check(py_items)) {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a sequence of five-element tuples");
        return NULL;
    }

    len = PySequence_Length(py_items);
    if (len > 0) {
        items = g_new(GtkStockItem, len);
        for (i = 0; i < len; i++) {
            py_item = PySequence_GetItem(py_items, i);
	    Py_DECREF(py_item);
            if (!py_item) goto error;
            if (!PyArg_ParseTuple(py_item, "zziiz",
                                  &items[i].stock_id, &items[i].label,
                                  &items[i].modifier, &items[i].keyval,
                                  &items[i].translation_domain)) {
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError, "items sequence members "
                                "must be of form (stock_id, label, modifiers, "
                                "keyval, domain)");
                goto error;
            }
        }
        gtk_stock_add(items, PySequence_Length(py_items));
        g_free(items);
    }
    Py_INCREF(Py_None);
    return Py_None;
 error:
    g_free(items);
    return NULL;
}
%%
override gtk_stock_list_ids noargs
static PyObject *
_wrap_gtk_stock_list_ids(PyGObject *self)
{
    GSList *ids;
    PyObject *list;
    int i = 0;

    ids = gtk_stock_list_ids();

    list = PyList_New(g_slist_length(ids));
    for (; ids; ids = ids->next, i++) {
        PyList_SetItem(list, i, PyString_FromString(ids->data));
        g_free(ids->data);
    }
    g_slist_free(ids);

    return list;
}
%%
override gtk_stock_lookup args
static PyObject *
_wrap_gtk_stock_lookup(PyGObject *self, PyObject *args)
{
    gchar *stock_id;
    GtkStockItem item;

    if (!PyArg_ParseTuple(args, "s:gtk.stock_lookup",
                          &stock_id)) {
        return NULL;
    }

    if(gtk_stock_lookup(stock_id, &item)) {
        return Py_BuildValue("zziiz",
                             item.stock_id,
                             item.label,
                             item.modifier,
                             item.keyval,
                             item.translation_domain);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_layout_get_size noargs
static PyObject *
_wrap_gtk_layout_get_size(PyGObject *self)
{
    guint width, height;
    gtk_layout_get_size(GTK_LAYOUT(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_frame_get_label_align noargs
static PyObject *
_wrap_gtk_frame_get_label_align(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_frame_get_label_align(GTK_FRAME(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_alignment noargs
static PyObject *
_wrap_gtk_misc_get_alignment(PyGObject *self)
{
    gfloat xalign, yalign;

    gtk_misc_get_alignment(GTK_MISC(self->obj), &xalign, &yalign);
    return Py_BuildValue("(ff)", xalign, yalign);
}
%%
override gtk_misc_get_padding noargs
static PyObject *
_wrap_gtk_misc_get_padding(PyGObject *self)
{
    gint xpad, ypad;

    gtk_misc_get_padding(GTK_MISC(self->obj), &xpad, &ypad);
    return Py_BuildValue("(ii)", xpad, ypad);
}
%%
override gtk_ruler_get_range noargs
static PyObject *
_wrap_gtk_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, position, max_size;

    gtk_ruler_get_range(GTK_RULER(self->obj), &lower, &upper, &position,
                        &max_size);
    return Py_BuildValue("(dddd)", lower, upper, position, max_size);
}
%%
override gtk_im_context_get_preedit_string noargs
static PyObject *
_wrap_gtk_im_context_get_preedit_string(PyGObject *self)
{
    gchar *str;
    PangoAttrList *attrs;
    gint cursor_pos;
    PyObject *ret;

    gtk_im_context_get_preedit_string(GTK_IM_CONTEXT(self->obj),
                                      &str, &attrs, &cursor_pos);

    ret = Py_BuildValue("(sNi)", str,
                        pyg_boxed_new(PANGO_TYPE_ATTR_LIST, attrs, FALSE,TRUE),
                        cursor_pos);
    g_free(str);

    return ret;
}
%%
override gtk_im_context_filter_keypress kwargs
static PyObject *
_wrap_gtk_im_context_filter_keypress(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "key", NULL };
    PyObject *key;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:GtkIMContext.filter_keypress", kwlist,
                                     &key))
        return NULL;

    if (!pyg_boxed_check(key, GDK_TYPE_EVENT)) {
        PyErr_SetString(PyExc_TypeError, "key must be a GdkEvent");
        return NULL;
    }

    ret = gtk_im_context_filter_keypress(GTK_IM_CONTEXT(self->obj),
                                         pyg_boxed_get(key, GdkEventKey))
        ? Py_True : Py_False;
    Py_INCREF(ret);
    return ret;
}
%%
override gtk_im_context_get_surrounding noargs
static PyObject *
_wrap_gtk_im_context_get_surrounding(PyGObject *self)
{
    gchar *text;
    gint cursor_index;

    if (gtk_im_context_get_surrounding(GTK_IM_CONTEXT(self->obj),
                                       &text, &cursor_index)) {
        PyObject *ret = Py_BuildValue("(si)", text, cursor_index);

        g_free(text);
        return ret;
    }
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override-attr GtkTooltips.active_tips_data
static PyObject *
_wrap_gtk_tooltips__get_active_tips_data(PyGObject *self, void *closure)
{
    GtkTooltips *tips = GTK_TOOLTIPS(self->obj);
    GtkTooltipsData *data = tips->active_tips_data;

    if (data == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
    }

    return Py_BuildValue("OOss",
                         pygobject_new((GObject *)data->tooltips),
                         pygobject_new((GObject *)data->widget),
                         data->tip_text,
                         data->tip_private);
}
%%
override-attr GtkTooltips.tips_data_list
static PyObject *
_wrap_gtk_tooltips__get_tips_data_list(PyGObject *self, void *closure)
{
    GList *list = GTK_TOOLTIPS(self->obj)->tips_data_list;
    gint         i, length;
    PyObject    *pylist;
    GList *iter;

    length = g_list_length(list);
    pylist = PyList_New(length);

    i = 0;
    for (iter = list; iter; iter = iter->next) {
        GtkTooltipsData *data = (GtkTooltipsData*)iter->data;
        PyObject *item = Py_BuildValue("OOss",
                               pygobject_new((GObject *)data->tooltips),
                               pygobject_new((GObject *)data->widget),
                               data->tip_text,
                               data->tip_private);
        PyList_SetItem(pylist, i, item);
        Py_INCREF(item);
    }
    return pylist;
}
%%
override-attr GtkAdjustment.value
static int
_wrap_gtk_adjustment__set_value(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "value must be a double");
        return -1;
    }
    adjustment->value = PyFloat_AsDouble(value);
    gtk_adjustment_value_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.lower
static int
_wrap_gtk_adjustment__set_lower(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "lower must be a double");
        return -1;
    }
    adjustment->lower = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.upper
static int
_wrap_gtk_adjustment__set_upper(PyGObject *self, PyObject *value,
                                void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "upper must be a double");
        return -1;
    }
    adjustment->upper = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.step_increment
static int
_wrap_gtk_adjustment__set_step_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "step_increment must be a double");
        return -1;
    }
    adjustment->step_increment = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_increment
static int
_wrap_gtk_adjustment__set_page_increment(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "page_increment must be a double");
        return -1;
    }
    adjustment->page_increment = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override-attr GtkAdjustment.page_size
static int
_wrap_gtk_adjustment__set_page_size(PyGObject *self, PyObject *value,
                                         void *closure)
{
    GtkAdjustment *adjustment = GTK_ADJUSTMENT(self->obj);

    if (!PyFloat_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "page_increment must be a double");
        return -1;
    }
    adjustment->page_size = PyFloat_AsDouble(value);
    gtk_adjustment_changed(adjustment);
    return 0;
}
%%
override gtk_adjustment_set_all kwargs
static PyObject *
_wrap_gtk_adjustment_set_all(PyGObject *self,
			     PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", "step_increment",
			      "page_increment", "page_size", NULL };
    GtkAdjustment *adj = GTK_ADJUSTMENT(self->obj);
    double *value = &adj->value, *lower = &adj->lower, *upper = &adj->upper;
    double *step_increment = &adj->step_increment;
    double *page_increment = &adj->page_increment;
    double *page_size = &adj->page_size;
    double old_value = *value, old_lower = *lower, old_upper = *upper;
    double old_step_increment = *step_increment;
    double old_page_increment = *page_increment;
    double old_page_size = *page_size;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|dddddd:gtk_adjustment_set_all",
				     kwlist,
				     value, lower, upper, step_increment,
				     page_increment, page_size)) {
        adj->value = old_value;
        adj->lower = old_lower;
        adj->upper = old_upper;
        adj->step_increment = old_step_increment;
        adj->page_increment = old_page_increment;
        adj->page_size = old_page_size;
        return NULL;
    }
    
    if (adj->value != old_value)
        gtk_adjustment_value_changed(adj);
    if (adj->lower != old_lower || adj->upper != old_upper
	|| adj->step_increment != old_step_increment
	|| adj->page_increment != old_page_increment
	|| adj->page_size != old_page_size)
        gtk_adjustment_changed(adj);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_file_selection_get_selections noargs
static PyObject *
_wrap_gtk_file_selection_get_selections(PyGObject *self)
{
    gchar **filenames = NULL;
    int size;
    int i;
    PyObject *ret;

    filenames = gtk_file_selection_get_selections(
        GTK_FILE_SELECTION(self->obj));

    for (i = 0; filenames[i]; i++);
    size = i;

    ret = PyTuple_New(size);
    for (i = 0; i < size; i++)
        PyTuple_SetItem(ret, i, PyString_FromString(filenames[i]));

    return ret;
}
%%
override gtk_icon_size_lookup kwargs
static PyObject *
_wrap_gtk_icon_size_lookup(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "icon_size", NULL };
    PyObject *py_icon_size;
    GtkIconSize icon_size;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:icon_size_lookup",
                                     kwlist, &py_icon_size))
        return NULL;

    if (pyg_enum_get_value(GTK_TYPE_ICON_SIZE, py_icon_size,
                           (gint *) &icon_size))
        return NULL;

    gtk_icon_size_lookup(icon_size, &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override gtk_image_get_pixmap noargs
static PyObject *
_wrap_gtk_image_get_pixmap(PyGObject *self)
{
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXMAP || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixmap or empty");
        return NULL;
    }
    gtk_image_get_pixmap(GTK_IMAGE(self->obj), &pixmap, &mask);
    return Py_BuildValue("(OO)", pygobject_new((GObject *)pixmap),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_image noargs
static PyObject *
_wrap_gtk_image_get_image(PyGObject *self)
{
    GdkImage *image;
    GdkBitmap *mask;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_IMAGE || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkImage or empty");
        return NULL;
    }
    gtk_image_get_image(GTK_IMAGE(self->obj), &image, &mask);
    return Py_BuildValue("(OO)", pygobject_new((GObject *)image),
			 pygobject_new((GObject *)mask));
}
%%
override gtk_image_get_stock noargs
static PyObject *
_wrap_gtk_image_get_stock(PyGObject *self)
{
    gchar *stock_id;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_STOCK || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a stock icon or empty");
        return NULL;
    }
    gtk_image_get_stock(GTK_IMAGE(self->obj), &stock_id, &size);

    if (stock_id) {
	return Py_BuildValue("(OO)",
			     PyString_FromString(stock_id),
			     PyInt_FromLong(size));
    } else {
	Py_INCREF(Py_None);
	return Py_BuildValue("(OO)", Py_None, PyInt_FromLong(size));
    }
}
%%
override gtk_image_get_icon_set noargs
static PyObject *
_wrap_gtk_image_get_icon_set(PyGObject *self)
{
    GtkIconSet *icon_set;
    GtkIconSize size;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ICON_SET || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GtkIconSet or empty");
        return NULL;
    }
    gtk_image_get_icon_set(GTK_IMAGE(self->obj), &icon_set, &size);
    return Py_BuildValue("(OO)", pygobject_new((GObject *)icon_set),
			 PyInt_FromLong(size));
}
%%
override gtk_image_get noargs
static PyObject *
_wrap_gtk_image_get(PyGObject *self)
{
    return _wrap_gtk_image_get_image(self);
}
%%
override gtk_image_get_pixbuf noargs
static PyObject *
_wrap_gtk_image_get_pixbuf(PyGObject *self)
{
    GdkPixbuf *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_PIXBUF || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbuf or empty");
        return NULL;
    }
    ret = gtk_image_get_pixbuf(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_image_get_animation noargs
static PyObject *
_wrap_gtk_image_get_animation(PyGObject *self)
{
    GdkPixbufAnimation *ret;
    GtkImageType type;

    type = gtk_image_get_storage_type(GTK_IMAGE(self->obj));
    if (!(type == GTK_IMAGE_ANIMATION || type == GTK_IMAGE_EMPTY)) {
	 PyErr_SetString(PyExc_ValueError, "image should be a GdkPixbufAnimation or empty");
        return NULL;
    }

    ret = gtk_image_get_animation(GTK_IMAGE(self->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gtk_radio_button_set_group kwargs
static PyObject *
_wrap_gtk_radio_button_set_group(PyGObject *self, PyObject *args,
				 PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioButton *group;

    if (!PyArg_ParseTupleAndKeywords(args,kwargs,"O!:GtkRadioButton.set_group",
                                     kwlist, &PyGtkRadioButton_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_BUTTON(pygobject_get(py_group));
    list = gtk_radio_button_get_group(group);
    if (list == gtk_radio_button_get_group(GTK_RADIO_BUTTON(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "radio button already in group");
        return NULL;
    }
    gtk_radio_button_set_group(GTK_RADIO_BUTTON(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_radio_menu_item_get_group noargs
static PyObject *
_wrap_gtk_radio_menu_item_get_group(PyGObject *self) {
    PyObject *py_list;
    GSList *list, *tmp;
    PyObject *gtk_obj;

    list = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj));

    if ((py_list = PyList_New(0)) == NULL) {
        return NULL;
    }
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        gtk_obj = pygobject_new(G_OBJECT(tmp->data));
        if (gtk_obj == NULL) {
            Py_DECREF(py_list);
            return NULL;
        }
        PyList_Append(py_list, gtk_obj);
        Py_DECREF(gtk_obj);
    }
    return py_list;
}
%%
override gtk_radio_menu_item_set_group kwargs
static PyObject *
_wrap_gtk_radio_menu_item_set_group(PyGObject *self, PyObject *args,
				    PyObject *kwargs) {
    static char *kwlist[] = { "group", NULL };
    PyObject *py_group;
    GSList *list;
    GtkRadioMenuItem *group;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkRadioMenuItem.set_group",
                                     kwlist, &PyGtkRadioMenuItem_Type,
				     &py_group))
        return NULL;
    group = GTK_RADIO_MENU_ITEM(pygobject_get(py_group));
    list = gtk_radio_menu_item_get_group(group);
    if (list == gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(self->obj))) {
        PyErr_SetString(PyExc_ValueError, "radio menu item already in group");
        return NULL;
    }
    gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(self->obj), list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_scrolled_window_get_policy  noargs
static PyObject *
_wrap_gtk_scrolled_window_get_policy(PyGObject *self)
{
    GtkPolicyType hscrollbar_policy, vscrollbar_policy;

    gtk_scrolled_window_get_policy(GTK_SCROLLED_WINDOW(self->obj),
				   &hscrollbar_policy, &vscrollbar_policy);
    return Py_BuildValue("(ii)", hscrollbar_policy, vscrollbar_policy);
}
%%
override gtk_tooltips_data_get kwargs
static PyObject *
_wrap_gtk_tooltips_data_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "widget", NULL };
    PyGObject *widget;
    GtkTooltipsData *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!:GtkTooltips.data_get",
				     kwlist, &PyGtkWidget_Type, &widget))
        return NULL;

    data = gtk_tooltips_data_get(GTK_WIDGET(widget->obj));

    if (!data) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    return Py_BuildValue("OOss",
			 pygobject_new((GObject *)data->tooltips),
			 pygobject_new((GObject *)data->widget),
			 data->tip_text,
			 data->tip_private);
}
%%
override gtk_accelerator_parse kwargs
static PyObject *
_wrap_gtk_accelerator_parse(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accelerator", NULL };
    gchar *accel;
    guint keyval;
    GdkModifierType modifier;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:Gtk.accelerator_parse",
				     kwlist, &accel))
        return NULL;

    gtk_accelerator_parse((const gchar *)accel, &keyval, &modifier);

    return Py_BuildValue("ii", keyval, modifier);
}
%%
override gtk_accel_map_lookup_entry kwargs
static PyObject *
_wrap_gtk_accel_map_lookup_entry(PyGObject *self, PyObject *args,
				 PyObject *kwargs)
{
    static char *kwlist[] = { "accel_path", NULL };
    gchar *accel_path;
    GtkAccelKey accel_key;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "s:gtk.accel_map_lookup_entry",
				     kwlist, &accel_path))
        return NULL;

    if (gtk_accel_map_lookup_entry((const gchar *)accel_path, &accel_key))
	return Py_BuildValue("ii", accel_key.accel_key, accel_key.accel_mods);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_load_fd kwargs
static PyObject *
_wrap_gtk_accel_map_load_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_load_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_load_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_accel_map_save_fd kwargs
static PyObject *
_wrap_gtk_accel_map_save_fd(PyGObject *self, PyObject *args,
			    PyObject *kwargs)
{
    static char *kwlist[] = { "fd", NULL };
    gint fd;
    PyObject *py_fd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O:gtk.accel_map_save_fd",
				     kwlist, &py_fd))
        return NULL;

    if ((fd = PyObject_AsFileDescriptor(py_fd)) != -1)
	gtk_accel_map_save_fd(fd);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gtk_color_selection_palette_from_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_from_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "str", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_list;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "s:gtk.color_selection_palette_from_string",
	kwlist, &str))
        return NULL;

    if (!gtk_color_selection_palette_from_string(str, &colors, &n_colors)) {
	Py_INCREF(Py_None);
	return Py_None;
    }

    if ((py_list = PyList_New(n_colors)) == NULL) {
	g_free(colors);
	return NULL;
    }

    for (i = 0; i < n_colors; i++) {
	PyObject *item = pyg_boxed_new(GDK_TYPE_COLOR, &colors[i], TRUE, TRUE);

	PyList_SetItem(py_list, i, item);
    }
    g_free(colors);

    return py_list;
}
%%
override gtk_color_selection_palette_to_string kwargs
static PyObject *
_wrap_gtk_color_selection_palette_to_string(PyGObject *self, PyObject *args,
					      PyObject *kwargs)
{
    static char *kwlist[] = { "colors", NULL };
    gchar *str;
    GdkColor *colors;
    gint i, n_colors;
    PyObject *py_colors, *ret;

    if (!PyArg_ParseTupleAndKeywords(
	args, kwargs, "O:gtk.color_selection_palette_to_string",
	kwlist, &py_colors))
        return NULL;

    n_colors = PySequence_Length(py_colors);
    if ((colors = g_new0(GdkColor, n_colors)) == NULL)
	return NULL;

    for (i = 0; i < n_colors; i++) {
        PyObject *item = PySequence_GetItem(py_colors, i);
	if (!pyg_boxed_check(item, GDK_TYPE_COLOR)) {
	    PyErr_SetString(PyExc_TypeError,
			    "colors must contain gtk.gdk.Colors");
	    g_free(colors);
	    Py_DECREF(item);
	    return NULL;
	}
	colors[i] = *pyg_boxed_get(item, GdkColor);
	Py_DECREF(item);
    }

    str = gtk_color_selection_palette_to_string(colors, n_colors);
    ret = PyString_FromString(str);
    g_free(colors);
    g_free(str);

    return ret;
}

%%
override gtk_binding_entry_remove kwargs
static PyObject *
_wrap_gtk_binding_entry_remove(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "class_type", "keyval", "modifiers", NULL };
    int keyval;
    PyObject *py_modifiers = NULL;
    GdkModifierType modifiers;
    PyObject *class;
    GType class_type;
    GtkBindingSet *bset = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OiO:gtk_binding_entry_remove",
				     kwlist, &class, &keyval, &py_modifiers))
        return NULL;
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_modifiers, (gint *)&modifiers))
        return NULL;

    class_type = pyg_type_from_object(class);
    if (class_type == 0)
        return NULL;

    bset = gtk_binding_set_by_class(gtk_type_class(class_type));
    gtk_binding_entry_remove(bset, keyval, modifiers);
    Py_INCREF(Py_None);
    return Py_None;
}

%%
define GtkAccelGroup.connect_group kwargs
static PyObject *
_wrap_gtk_accel_group_connect_group(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "accel_key", "accel_mods", "accel_flags", "callback", NULL };
    int accel_key;
    PyObject *py_accel_mods = NULL, *py_accel_flags = NULL, *py_callback;
    GdkModifierType accel_mods;
    GtkAccelFlags accel_flags;
    GClosure *closure;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "iOOO:GtkAccelGroup.connect", kwlist,
				     &accel_key, &py_accel_mods, &py_accel_flags,
				     &py_callback))
        return NULL;
    if (!PyCallable_Check(py_callback)) {
	PyErr_SetString(PyExc_TypeError, "callback argument not callable");
	return NULL;
    }
    if (pyg_flags_get_value(GDK_TYPE_MODIFIER_TYPE, py_accel_mods, (gint *)&accel_mods))
        return NULL;
    if (pyg_flags_get_value(GTK_TYPE_ACCEL_FLAGS, py_accel_flags, (gint *)&accel_flags))
        return NULL;
    closure = pyg_closure_new(py_callback, NULL, NULL);
    pygobject_watch_closure((PyObject *)self, closure);
    gtk_accel_group_connect(GTK_ACCEL_GROUP(self->obj), accel_key,
			    accel_mods, accel_flags, closure);
    Py_INCREF(Py_None);
    return Py_None;
}
