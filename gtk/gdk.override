/* -*- Mode: C; c-basic-offset: 4 -*-
 * pygtk- Python bindings for the GTK toolkit.
 * Copyright (C) 1998-2003  James Henstridge
 *
 *   gdk.override: overrides for the gtk.gdk module.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */
%%
headers
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <gtk/gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "pygtk-private.h"

#if defined(GDK_WINDOWING_X11)
#include <gdk/gdkx.h>
#elif defined(GDK_WINDOWING_WIN32)
#include <gdk/gdkwin32.h>
#endif

/* make GDK_DISPLAY() the case macro */
#undef GDK_DISPLAY
#define GDK_DISPLAY(object) (GDK_DISPLAY_OBJECT(object))

#ifdef HAVE_NUMPY
#  include <Numeric/arrayobject.h>
static int have_numpy(void);
#endif

extern PyTypeObject PyGtkWidget_Type;

%%
modulename gtk.gdk
%%
import gobject.GObject as PyGObject_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore-glob
  *_get_type
  _*
  *_ref
  *_unref
%%
ignore-win32
  gdk_font_get_display
  gdk_pixmap_lookup
%%
override gdk_threads_init noargs

/* block/unblock threads implementations using GDK lock to handle
 * recursion (as in 1.2 version).  Here is the comments about it from
 * the 1.2 version of pygtk:*/

/* The threading hacks are based on ones supplied by Duncan Grisby
 * of AT&T Labs Cambridge.  Since then they have been modified a bit. */

/* The threading code has been enhanced to be a little better with multiple
 * threads accessing GTK+.  Here are some notes on the changes by
 * Paul Fisher:
 *
 * If threading is enabled, we create a recursive version of Python's
 * global interpreter mutex using TSD.  This scheme makes it possible,
 * although rather hackish, for any thread to make a call into PyGTK,
 * as long as the GDK lock is held (that is, Python code is wrapped
 * around a threads_{enter,leave} pair).
 *
 * A viable alternative would be to wrap each and every GTK call, at
 * the Python/C level, with Py_{BEGIN,END}_ALLOW_THREADS.  However,
 * given the nature of Python threading, this option is not
 * particularly appealing.
 */
#ifdef ENABLE_PYGTK_THREADING
static GStaticPrivate pythreadstate_key = G_STATIC_PRIVATE_INIT;
static GStaticPrivate lock_count_key = G_STATIC_PRIVATE_INIT;
static PyInterpreterState *pyinterpstate = NULL;

static gint *
pygdk_get_lock_count(void)
{
    gint *lock_count = g_static_private_get(&lock_count_key);

    if(!lock_count) {
	lock_count = g_malloc(sizeof(gint));
	*lock_count = 1;
	g_static_private_set(&lock_count_key, lock_count, NULL);
    }

    return lock_count;
}

static void
pygdk_block_threads (void)
{
    PyThreadState *_save;
    gint *lock_count = pygdk_get_lock_count();

    (*lock_count)++;
    if(*lock_count == 1) {
	_save = g_static_private_get(&pythreadstate_key);
	g_assert(_save);
	Py_BLOCK_THREADS;
	g_static_private_set(&pythreadstate_key, NULL, NULL);
    }
}

static void
pygdk_unblock_threads (void)
{
    PyThreadState *_save;
    gint *lock_count = pygdk_get_lock_count();

    if(*lock_count == 1) {
        Py_UNBLOCK_THREADS;
        g_static_private_set(&pythreadstate_key, _save, NULL);
    }
    (*lock_count)--;
}
#endif

static PyObject *
_wrap_gdk_threads_init(PyObject *self)
{
#ifdef ENABLE_PYGTK_THREADING
    /* register gdk thread block/unblock routines with gobjectmodule */
    pyg_set_thread_block_funcs (pygdk_block_threads, pygdk_unblock_threads);

    PyEval_InitThreads();
    gdk_threads_init();

    pyinterpstate = PyThreadState_Get()->interp;

    Py_INCREF(Py_None);
    return Py_None;
#else
    PyErr_SetString(PyExc_RuntimeError,
                    "pygtk threading disabled at compile time");
    return NULL;
#endif
}
%%
override gdk_threads_enter noargs
static PyObject *
_wrap_gdk_threads_enter(PyObject *self)
{
    /* must allow threads while acquiring lock, or no other python
     * code will execute while we wait! */
    Py_BEGIN_ALLOW_THREADS;
    gdk_threads_enter();
    Py_END_ALLOW_THREADS;

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_polygon kwargs
static PyObject *
_wrap_gdk_draw_polygon(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "filled", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint filled, npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!iO:GdkDrawable.draw_polygon", kwlist,
                                     &PyGdkGC_Type, &gc, &filled, &py_points))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "ii", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gdk_draw_polygon(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), filled,
                     points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_text kwargs
static PyObject *
_wrap_gdk_draw_text(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "font", "gc", "x", "y", "text",NULL};
    PyGObject *gc;
    PyObject *font;
    int x, y, len;
    char *text;
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO!iis#:GdkDrawable.draw_text", kwlist,
                                     &font, &PyGdkGC_Type, &gc,
                                     &x, &y, &text, &len))
        return NULL;
    if (!pyg_boxed_check(font, GDK_TYPE_FONT)) {
        PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
        return NULL;
    }
    gdk_draw_text(GDK_DRAWABLE(self->obj), pyg_boxed_get(font, GdkFont),
                  GDK_GC(gc->obj), x, y, text, len);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_points kwargs
static PyObject *
_wrap_gdk_draw_points(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GdkDrawable.draw_points", kwlist,
                                     &PyGdkGC_Type, &gc, &py_points))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "ii", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gdk_draw_points(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_segments kwargs
static PyObject *
_wrap_gdk_draw_segments(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "segs", NULL };
    PyGObject *gc;
    PyObject *py_segs;
    gint nsegs, i;
    GdkSegment *segs;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GdkDrawable.draw_segments", kwlist,
                                     &PyGdkGC_Type, &gc, &py_segs))
        return NULL;
    if (!PySequence_Check(py_segs)) {
        PyErr_SetString(PyExc_TypeError, "segs must be a sequence");
        return NULL;
    }
    nsegs = PySequence_Length(py_segs);
    segs = g_new(GdkSegment, nsegs);
    for (i = 0; i < nsegs; i++) {
        PyObject *item = PySequence_GetItem(py_segs, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "iiii", &segs[i].x1, &segs[i].y1,
                              &segs[i].x2, &segs[i].y2)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 4-tuples");
            g_free(segs);
            return NULL;
        }
    }
    gdk_draw_segments(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), segs, nsegs);
    g_free(segs);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_lines kwargs
static PyObject *
_wrap_gdk_draw_lines(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "points", NULL };
    PyGObject *gc;
    PyObject *py_points;
    gint npoints, i;
    GdkPoint *points;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O:GdkDrawable.draw_lines", kwlist,
                                     &PyGdkGC_Type, &gc, &py_points))
        return NULL;
    if (!PySequence_Check(py_points)) {
        PyErr_SetString(PyExc_TypeError, "points must be a sequence");
        return NULL;
    }
    npoints = PySequence_Length(py_points);
    points = g_new(GdkPoint, npoints);
    for (i = 0; i < npoints; i++) {
        PyObject *item = PySequence_GetItem(py_points, i);
        Py_DECREF(item);
        if (!PyArg_ParseTuple(item, "ii", &points[i].x, &points[i].y)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_TypeError,
                            "sequence members must be 2-tuples");
            g_free(points);
            return NULL;
        }
    }
    gdk_draw_lines(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), points, npoints);
    g_free(points);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_rgb_image kwargs
static PyObject *
_wrap_gdk_draw_rgb_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "x", "y", "width", "height", "dith",
                              "rgb_buf", "rowstride", "xdith", "ydith", NULL };
    PyGObject *gc;
    PyObject *py_dith;
    gint x, y, width, height, rowstride = -1, xdith = 0, ydith = 0, len;
    GdkRgbDither dith;
    guchar *rgb_buf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!iiiiOs#|iii:GdkDrawable.draw_rgb_image",
                                     kwlist, &PyGdkGC_Type, &gc, &x, &y,
                                     &width, &height, &py_dith,
                                     &rgb_buf, &len, &rowstride,
                                     &xdith, &ydith))
        return NULL;

    if (pyg_enum_get_value(GDK_TYPE_RGB_DITHER, py_dith, (gint *)&dith))
        return NULL;
    if (!(width > 0 && height > 0)) {
        PyErr_SetString(PyExc_ValueError,
                        "height and width must be greater than zero");
        return NULL;
    }
    if (rowstride == -1) rowstride = width * 3;
    if (len < rowstride * (height - 1) + width*3) {
        PyErr_SetString(PyExc_IndexError, "rgb_buf is not large enough");
        return NULL;
    }
    gdk_draw_rgb_image_dithalign(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj),
                                 x, y, width, height, dith, rgb_buf,
                                 rowstride, xdith, ydith);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gdk_draw_rgb_image_dithalign
%%
override gdk_draw_rgb_32_image kwargs
static PyObject *
_wrap_gdk_draw_rgb_32_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "x", "y", "width", "height", "dith",
                              "rgb_buf", "rowstride", "xdith", "ydith", NULL };
    PyGObject *gc;
    PyObject *py_dith;
    gint x, y, width, height, rowstride = -1, xdith = 0, ydith = 0, len;
    GdkRgbDither dith;
    guchar *rgb_buf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                "O!iiiiOs#|iii:GdkDrawable.draw_rgb_32_image",
                                     kwlist, &PyGdkGC_Type, &gc, &x, &y,
                                     &width, &height, &py_dith,
                                     &rgb_buf, &len, &rowstride,
                                     &xdith, &ydith))
        return NULL;

    if (pyg_enum_get_value(GDK_TYPE_RGB_DITHER, py_dith, (gint *)&dith))
        return NULL;
    if (!(width > 0 && height > 0)) {
        PyErr_SetString(PyExc_ValueError,
                        "height and width must be greater than zero");
        return NULL;
    }
    if (rowstride == -1) rowstride = width * 4;
    if (len < rowstride * (height - 1) + width*4) {
        PyErr_SetString(PyExc_IndexError, "rgb_buf is not large enough");
        return NULL;
    }
    gdk_draw_rgb_32_image_dithalign(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj),
                                    x, y, width, height, dith, rgb_buf,
                                    rowstride, xdith, ydith);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore gdk_draw_rgb_32_image_dithalign
%%
override gdk_draw_gray_image kwargs
static PyObject *
_wrap_gdk_draw_gray_image(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "x", "y", "width", "height", "dith",
                              "buf", "rowstride", NULL };
    PyGObject *gc;
    PyObject *py_dith;
    gint x, y, width, height, rowstride = -1, len;
    GdkRgbDither dith;
    guchar *buf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!iiiiOs#|i:GdkDrawable.draw_gray_image",
                                     kwlist, &PyGdkGC_Type, &gc, &x, &y,
                                     &width, &height, &py_dith,
                                     &buf, &len, &rowstride))
        return NULL;

    if (pyg_enum_get_value(GDK_TYPE_RGB_DITHER, py_dith, (gint *)&dith))
        return NULL;
    if (!(width > 0 && height > 0)) {
        PyErr_SetString(PyExc_ValueError,
                        "height and width must be greater than zero");
        return NULL;
    }
    if (rowstride == -1) rowstride = width;
    if (len < rowstride * (height - 1) + width) {
        PyErr_SetString(PyExc_IndexError, "buf is not large enough");
        return NULL;
    }
    gdk_draw_gray_image(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), x, y,
                        width, height, dith, buf, rowstride);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
ignore
  gdk_color_copy gdk_color_free
  gdk_color_hash gdk_color_equal
%%
override gdk_color_new kwargs
static int
_wrap_gdk_color_new(PyGBoxed *self,
                    PyObject *args,
                    PyObject *kwargs)
{
    static char *kwlist[] = {"red", "green", "blue", "pixel", NULL };
    GdkColor colour = {0, 0, 0, 0};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiii:gdk.Color", kwlist,
                                     &(colour.red), &(colour.green),
                                     &(colour.blue), &(colour.pixel))) {
        return -1;
    }
    
    self->boxed =  g_boxed_copy(GDK_TYPE_COLOR, &colour);
    self->free_on_dealloc = TRUE;
    self->gtype = GDK_TYPE_COLOR;
    
    return 0;
}
%%
override-slot GdkColor.tp_setattr
static int
_wrap_gdk_color_tp_setattr(PyGBoxed *self, char *attr, PyObject *value)
{
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "can't delete attributes");
        return -1;
    }

    if (PyInt_Check(value)) {
        int i = PyInt_AsLong(value);
        if (!strcmp(attr, "red")) {
            pyg_boxed_get(self, GdkColor)->red = i;
            return 0;
        } else if (!strcmp(attr, "green")) {
            pyg_boxed_get(self, GdkColor)->green = i;       
            return 0;
        } else if (!strcmp(attr, "blue")) {
            pyg_boxed_get(self, GdkColor)->blue = i;
            return 0;
        } else if (!strcmp(attr, "pixel")) {
            pyg_boxed_get(self, GdkColor)->pixel = i;
            return 0;
        } 
    }

    PyErr_SetString(PyExc_AttributeError, "could not write attribute");
    return -1;
}
%%
override gdk_color_parse kwargs
static PyObject *
_wrap_gdk_color_parse(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "spec", NULL };
    const char *spec;
    GdkColor colour;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:color_parse", kwlist,
                                     &spec))
        return NULL;

    gdk_color_parse (spec, &colour);
    
    /* pyg_boxed_new handles NULL checking */    
    return pyg_boxed_new (GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gdk_fontset_load kwargs
static PyObject *
_wrap_gdk_fontset_load(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fontset_name", NULL };
    char *fontset_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:fontset_load", kwlist,
                                     &fontset_name))
        return NULL;

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(GDK_TYPE_FONT, gdk_fontset_load(fontset_name),
                         FALSE, TRUE);
}
%%
override gdk_text_extents kwargs
static PyObject *
_wrap_gdk_text_extents(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "text", NULL };
    gchar *text;
    gint length;
    gint lbearing, rbearing, width, ascent, descent;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s#:GdkFont.extents",
                                     kwlist, &text, &length))
        return NULL;
    gdk_text_extents(pyg_boxed_get(self, GdkFont), text, length,
                     &lbearing, &rbearing, &width, &ascent, &descent);
    return Py_BuildValue("(iiiii)", lbearing, rbearing, width,
                         ascent, descent);
}
%%
override gdk_pixmap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm(PyObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "filename", NULL};
    PyGObject *window;
    PyObject *py_trans_color, *ret;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!Os:pixmap_create_from_xpm", kwlist,
                                     &PyGdkWindow_Type, &window,
                                     &py_trans_color, &filename))
        return NULL;
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
        trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "transparent_color must be a colour or None");
        return NULL;
    }
    pixmap = gdk_pixmap_create_from_xpm(GDK_WINDOW(window->obj), &mask,
                                        trans_color, filename);
    if (pixmap == NULL) {
        PyErr_SetString(PyExc_IOError, "can't load pixmap");
        return NULL;
    }
    ret = Py_BuildValue("(NN)",
                        pygobject_new((GObject *)pixmap),
                        pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm(PyObject *self, PyObject *args,
                                          PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
                              "filename", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar *filename;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOOs:pixmap_colormap_create_from_xpm",
                                     kwlist, &py_window, &py_colormap,
                                     &py_trans_color, &filename))
        return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
        window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
        PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
        return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
        colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "colormap must be a GdkColormap or None");
        return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
        trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "transparent_color must be a colour or None");
        return NULL;
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm(window, colormap, &mask,
                                                 trans_color, filename);
    if (pixmap == NULL) {
        PyErr_SetString(PyExc_IOError, "can't load pixmap");
        return NULL;
    }
    ret = Py_BuildValue("(NN)",
                        pygobject_new((GObject *)pixmap),
                        pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_create_from_xpm_d(PyObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "window", "transparent_color", "data", NULL };
    PyGObject *window;
    PyObject *py_trans_color, *py_data, *ret;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!OO!:pixmap_create_from_xpm_d", kwlist,
                                     &PyGdkWindow_Type, &window,
                                     &py_trans_color, &PyList_Type, &py_data))
        return NULL;
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
        trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "transparent_color must be a colour or None");
        return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
        PyObject *item = PyList_GetItem(py_data, i);
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "data items must be strings");
            g_free(data);
            return NULL;
        }
        data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_create_from_xpm_d(GDK_WINDOW(window->obj), &mask,
                                          trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
        PyErr_SetString(PyExc_IOError, "can't load pixmap");
        return NULL;
    }
    ret = Py_BuildValue("(NN)",
                        pygobject_new((GObject *)pixmap),
                        pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
override gdk_pixmap_colormap_create_from_xpm_d kwargs
static PyObject *
_wrap_gdk_pixmap_colormap_create_from_xpm_d(PyObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    static char *kwlist[] = { "window", "colormap", "transparent_color",
                              "data", NULL };
    PyObject *py_window, *py_colormap, *py_trans_color, *py_data, *ret;
    GdkWindow *window = NULL;
    GdkColormap *colormap = NULL;
    GdkColor *trans_color = NULL;
    gchar **data;
    int len, i;
    GdkPixmap *pixmap;
    GdkBitmap *mask;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOOO!:pixmap_colormap_create_from_xpm_d",
                                     kwlist, &py_window, &py_colormap,
                                     &py_trans_color,
                                     &PyList_Type, &py_data))
        return NULL;
    if (pygobject_check(py_window, &PyGdkWindow_Type))
        window = GDK_WINDOW(pygobject_get(py_window));
    else if (py_window != Py_None) {
        PyErr_SetString(PyExc_TypeError, "window must be a GdkWindow or None");
        return NULL;
    }
    if (pygobject_check(py_colormap, &PyGdkColormap_Type))
        colormap = GDK_COLORMAP(pygobject_get(py_colormap));
    else if (py_colormap != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "colormap must be a GdkColormap or None");
        return NULL;
    }
    if (pyg_boxed_check(py_trans_color, GDK_TYPE_COLOR))
        trans_color = pyg_boxed_get(py_trans_color, GdkColor);
    else if (py_trans_color != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "transparent_color must be a colour or None");
        return NULL;
    }
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
        PyObject *item = PyList_GetItem(py_data, i);
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "data items must be strings");
            g_free(data);
            return NULL;
        }
        data[i] = PyString_AsString(item);
    }
    pixmap = gdk_pixmap_colormap_create_from_xpm_d(window, colormap, &mask,
                                                   trans_color, data);
    g_free(data);
    if (pixmap == NULL) {
        PyErr_SetString(PyExc_IOError, "can't load pixmap");
        return NULL;
    }
    ret = Py_BuildValue("(NN)",
                        pygobject_new((GObject *)pixmap),
                        pygobject_new((GObject *)mask));
    gdk_pixmap_unref(pixmap);
    gdk_bitmap_unref(mask);
    return ret;
}
%%
ignore gdk_cursor_new_from_pixmap
%%
override gdk_cursor_new kwargs
static int
_wrap_gdk_cursor_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist1[] = { "cursor_type", NULL };
    static char *kwlist2[] = { "source", "mask", "fg", "bg", "x", "y", NULL };
    PyObject *py_cursor_type;

    self->gtype = GDK_TYPE_CURSOR;
    self->free_on_dealloc = FALSE;
    self->boxed = NULL;
    if (PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkCursor.__init__",
                                    kwlist1, &py_cursor_type)) {
        GdkCursorType cursor_type;

        if (pyg_enum_get_value(GDK_TYPE_CURSOR_TYPE, py_cursor_type,
                               (gint *)&cursor_type))
            return -1;
        self->boxed = gdk_cursor_new(cursor_type);
        if (!self->boxed) {
            PyErr_SetString(PyExc_RuntimeError,
                            "could not create GdkCursor object");
            return -1;
        }
        self->free_on_dealloc = TRUE;
    } else {
        PyGObject *source, *mask;
        PyObject *fg, *bg;
        gint x, y;
        PyErr_Clear();

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "OOOOii:GdkCursor.__init__", kwlist2,
                                         &source, &mask, &fg, &bg, &x, &y))
            return -1;
        if (!pygobject_check(source, &PyGdkPixmap_Type)) {
            PyErr_SetString(PyExc_TypeError, "source should be a GdkPixmap");
            return -1;
        }
        if (!pygobject_check(mask, &PyGdkPixmap_Type)) {
            PyErr_SetString(PyExc_TypeError, "mask should be a GdkPixmap");
            return -1;
        }
        if (!pyg_boxed_check(fg, GDK_TYPE_COLOR)) {
            PyErr_SetString(PyExc_TypeError, "fg should be a GdkColor");
            return -1;
        }
        if (!pyg_boxed_check(bg, GDK_TYPE_COLOR)) {
            PyErr_SetString(PyExc_TypeError, "bg should be a GdkColor");
            return -1;
        }
        self->boxed = gdk_cursor_new_from_pixmap(GDK_PIXMAP(source->obj),
                                                 GDK_PIXMAP(mask->obj),
                                                 pyg_boxed_get(fg, GdkColor),
                                                 pyg_boxed_get(bg, GdkColor),
                                                 x, y);
        if (!self->boxed) {
            PyErr_SetString(PyExc_RuntimeError,
                            "could not create GdkCursor object");
            return -1;
        }
        self->free_on_dealloc = TRUE;
    }
    return 0;
}
%%
override-slot GdkEvent.tp_getattr
PyObject *
_wrap_gdk_event_tp_getattr(PyObject *self, char *attr)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    guint i;

    switch(event->type) {
    case GDK_NOTHING: break;
    case GDK_DELETE: break;
    case GDK_DESTROY: break;
    case GDK_EXPOSE:            /*GdkEventExpose            expose*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssss]",
                                 "type", "window", "send_event",
                                 "area", "count");
        if (!strcmp(attr, "area"))
            return pyg_boxed_new(GDK_TYPE_RECTANGLE, &event->expose.area,
                                 TRUE, TRUE);
        if (!strcmp(attr, "count"))
            return PyInt_FromLong(event->expose.count);
        break;
    case GDK_MOTION_NOTIFY:     /*GdkEventMotion            motion*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssssssssssss]",
                                 "type", "window", "send_event",
                                 "time", "x", "y", "axes", "state",
                                 "is_hint", "device", "x_root", "y_root");
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->motion.time);
        if (!strcmp(attr, "x"))
            return PyFloat_FromDouble(event->motion.x);
        if (!strcmp(attr, "y"))
            return PyFloat_FromDouble(event->motion.y);
        if (!strcmp(attr, "axes")) {
            if (event->motion.axes) {
                PyObject *v = PyTuple_New(event->motion.device->num_axes);
                if (!v) return NULL;
                for (i = 0; i < event->motion.device->num_axes; i++)
                    PyTuple_SetItem(v, i,PyFloat_FromDouble(
                                                event->motion.axes[i]));
                return v;
            } else {
                Py_INCREF(Py_None);
                return Py_None;
            }
        }
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->motion.state);
        if (!strcmp(attr, "is_hint"))
            return PyInt_FromLong(event->motion.is_hint);
        if (!strcmp(attr, "device"))
            return pygobject_new((GObject *)event->motion.device);
        if (!strcmp(attr, "x_root"))
            return PyFloat_FromDouble(event->motion.x_root);
        if (!strcmp(attr, "y_root"))
            return PyFloat_FromDouble(event->motion.y_root);
        break;
    case GDK_BUTTON_PRESS:      /*GdkEventButton            button*/
    case GDK_2BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_3BUTTON_PRESS:     /*GdkEventButton            button*/
    case GDK_BUTTON_RELEASE:    /*GdkEventButton            button*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssssssssssss]",
                                 "type", "window", "send_event",
                                 "time", "x", "y", "axes", "state",
                                 "button", "device", "x_root", "y_root");
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->button.time);
        if (!strcmp(attr, "x"))
            return PyFloat_FromDouble(event->button.x);
        if (!strcmp(attr, "y"))
            return PyFloat_FromDouble(event->button.y);
        if (!strcmp(attr, "axes")) {
            if (event->button.axes) {
                PyObject *v = PyTuple_New(event->button.device->num_axes);
                if (!v) return NULL;
                for (i = 0; i < event->button.device->num_axes; i++)
                    PyTuple_SetItem(v, i,PyFloat_FromDouble(
                                                event->button.axes[i]));
                return v;
            } else {
                Py_INCREF(Py_None);
                return Py_None;
            }
        }
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->button.state);
        if (!strcmp(attr, "button"))
            return PyInt_FromLong(event->button.button);
        if (!strcmp(attr, "device"))
            return pygobject_new((GObject *)event->button.device);
        if (!strcmp(attr, "x_root"))
            return PyFloat_FromDouble(event->button.x_root);
        if (!strcmp(attr, "y_root"))
            return PyFloat_FromDouble(event->button.y_root);
        break;
    case GDK_KEY_PRESS:         /*GdkEventKey               key*/
    case GDK_KEY_RELEASE:       /*GdkEventKey               key*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssssss]",
                                 "type", "window", "send_event",
                                 "time", "state", "keyval", "string",
				 "hardware_keycode");
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->key.time);
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->key.state);
        if (!strcmp(attr, "keyval"))
            return PyInt_FromLong(event->key.keyval);
        if (!strcmp(attr, "string"))
            return PyString_FromStringAndSize(event->key.string,
                                              event->key.length);
        if (!strcmp(attr, "hardware_keycode"))
            return PyInt_FromLong(event->key.hardware_keycode);
        break;
    case GDK_ENTER_NOTIFY:      /*GdkEventCrossing          crossing*/
    case GDK_LEAVE_NOTIFY:      /*GdkEventCrossing          crossing*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssssssssssss]",
                                 "type", "window", "send_event",
                                 "subwindow", "time", "x", "y",
                                 "x_root", "y_root", "mode", "detail",
                                 "focus", "state");
        if (!strcmp(attr, "subwindow"))
            return pygobject_new((GObject *)event->crossing.subwindow);
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->crossing.time);
        if (!strcmp(attr, "x"))
            return PyFloat_FromDouble(event->crossing.x);
        if (!strcmp(attr, "y"))
            return PyFloat_FromDouble(event->crossing.y);
        if (!strcmp(attr, "x_root"))
            return PyFloat_FromDouble(event->crossing.x_root);
        if (!strcmp(attr, "y_root"))
            return PyFloat_FromDouble(event->crossing.y_root);
        if (!strcmp(attr, "mode"))
            return PyInt_FromLong(event->crossing.mode);
        if (!strcmp(attr, "detail"))
            return PyInt_FromLong(event->crossing.detail);
        if (!strcmp(attr, "focus"))
            return PyInt_FromLong(event->crossing.focus);
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->crossing.state);
        break;
    case GDK_FOCUS_CHANGE:      /*GdkEventFocus             focus_change*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssss]",
                                 "type", "window", "send_event",
                                 "in_");
        if (!strcmp(attr, "in_"))
            return PyInt_FromLong(event->focus_change.in);
        break;
    case GDK_CONFIGURE:         /*GdkEventConfigure         configure*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssssss]",
                                 "type", "window", "send_event",
                                 "x", "y", "width", "height");
        if (!strcmp(attr, "x"))
            return PyInt_FromLong(event->configure.x);
        if (!strcmp(attr, "y"))
            return PyInt_FromLong(event->configure.y);
        if (!strcmp(attr, "width"))
            return PyInt_FromLong(event->configure.width);
        if (!strcmp(attr, "height"))
            return PyInt_FromLong(event->configure.height);
        break;
    case GDK_MAP: break;
    case GDK_UNMAP: break;
    case GDK_PROPERTY_NOTIFY:   /*GdkEventProperty          property*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssssss]",
                                 "type", "window", "send_event",
                                 "atom", "time", "state");
        if (!strcmp(attr, "atom"))
            return PyGdkAtom_New(event->property.atom);
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->property.time);
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->property.state);
        break;
    case GDK_SELECTION_CLEAR:   /*GdkEventSelection         selection*/
    case GDK_SELECTION_REQUEST: /*GdkEventSelection         selection*/
    case GDK_SELECTION_NOTIFY:  /*GdkEventSelection         selection*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssssssss]",
                                 "type", "window", "send_event",
                                 "selection", "target", "property",
                                 "requestor", "time");
        if (!strcmp(attr, "selection"))
            return PyGdkAtom_New(event->selection.selection);
        if (!strcmp(attr, "target"))
            return PyGdkAtom_New(event->selection.target);
        if (!strcmp(attr, "property"))
            return PyGdkAtom_New(event->selection.property);
        if (!strcmp(attr, "requestor"))
            return PyInt_FromLong(event->selection.requestor);
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->selection.time);
        break;
    case GDK_PROXIMITY_IN:      /*GdkEventProximity         proximity*/
    case GDK_PROXIMITY_OUT:     /*GdkEventProximity         proximity*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssss]",
                                 "type", "window", "send_event",
                                 "time", "device");
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->proximity.time);
        if (!strcmp(attr, "device"))
            return pygobject_new((GObject *)event->proximity.device);
        break;
    case GDK_DRAG_ENTER:        /*GdkEventDND               dnd*/
    case GDK_DRAG_LEAVE:        /*GdkEventDND               dnd*/
    case GDK_DRAG_MOTION:       /*GdkEventDND               dnd*/
    case GDK_DRAG_STATUS:       /*GdkEventDND               dnd*/
    case GDK_DROP_START:        /*GdkEventDND               dnd*/
    case GDK_DROP_FINISHED:     /*GdkEventDND               dnd*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssssss]",
                                 "type", "window", "send_event",
                                 "context", "time", "x_root", "y_root");
        if (!strcmp(attr, "context"))
            return pygobject_new((GObject *)event->dnd.context);
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->dnd.time);
        if (!strcmp(attr, "x_root"))
            return PyFloat_FromDouble(event->dnd.x_root);
        if (!strcmp(attr, "y_root"))
            return PyFloat_FromDouble(event->dnd.y_root);
        break;
    case GDK_CLIENT_EVENT:      /*GdkEventClient            client*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssssss]",
                                 "type", "window", "send_event",
                                 "message_type", "data_format", "data");
        if (!strcmp(attr, "message_type"))
            return PyGdkAtom_New(event->client.message_type);
        if (!strcmp(attr, "data_format"))
            return PyInt_FromLong(event->client.data_format);
        if (!strcmp(attr, "data"))
            return PyString_FromStringAndSize(event->client.data.b, 20);
        break;
    case GDK_VISIBILITY_NOTIFY: /*GdkEventVisibility        visibility*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[ssss]",
                                 "type", "window", "send_event",
                                 "state");
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->visibility.state);
        break;
    case GDK_NO_EXPOSE:         /*GdkEventNoExpose          no_expose*/
        break;
    case GDK_SCROLL:            /*GdkEventScroll            scroll*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssssssssss]",
                                 "type", "window", "send_event",
                                 "time", "x", "y", "state", "direction",
                                 "device", "x_root", "y_root");
        if (!strcmp(attr, "time"))
            return PyInt_FromLong(event->scroll.time);
        if (!strcmp(attr, "x"))
            return PyFloat_FromDouble(event->scroll.x);
        if (!strcmp(attr, "y"))
            return PyFloat_FromDouble(event->scroll.y);
        if (!strcmp(attr, "state"))
            return PyInt_FromLong(event->scroll.state);
        if (!strcmp(attr, "direction"))
            return PyInt_FromLong(event->scroll.direction);
        if (!strcmp(attr, "device"))
            return pygobject_new((GObject *)event->scroll.device);
        if (!strcmp(attr, "x_root"))
            return PyFloat_FromDouble(event->scroll.x_root);
        if (!strcmp(attr, "y_root"))
            return PyFloat_FromDouble(event->scroll.y_root);
        break;
    case GDK_WINDOW_STATE:      /*GdkEventWindowState       window_state*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssss]",
                                 "type", "window", "send_event",
                                 "changed_mask", "new_window_state");
        if (!strcmp(attr, "changed_mask"))
            return PyInt_FromLong(event->window_state.changed_mask);
        if (!strcmp(attr, "new_window_state"))
            return PyInt_FromLong(event->window_state.new_window_state);
        break;
    case GDK_SETTING:           /*GdkEventSetting           setting*/
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssss]",
                                 "type", "window", "send_event",
                                 "action", "name");
        if (!strcmp(attr, "action"))
            return PyInt_FromLong(event->setting.action);
        if (!strcmp(attr, "name"))
            return PyString_FromString(event->setting.name);
        break;
    default:
        break;
    }
    
    if (!strcmp(attr, "type"))
        return PyInt_FromLong(event->type);
    if (!strcmp(attr, "window"))
        return pygobject_new((GObject *)event->any.window);
    if (!strcmp(attr, "send_event"))
        return PyInt_FromLong(event->any.send_event);
    if (!strcmp(attr, "__members__"))
        return Py_BuildValue("[sss]", "type", "window", "send_event");

    return Py_FindMethod(_PyGdkEvent_methods, self, attr);
}
%%
override gdk_event_get_axis args
static PyObject *
_wrap_gdk_event_get_axis(PyGObject *self, PyObject *args)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    gint axis_use;
    gdouble value;

    if (!PyArg_ParseTuple(args, "i:gdk.event_get_axis",
                          &axis_use))
        return NULL;
                                     
    if (gdk_event_get_axis(event, axis_use, &value)) {
        return PyFloat_FromDouble(value);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gdk_event_get_coords noargs
static PyObject *
_wrap_gdk_event_get_coords(PyGObject *self)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    gdouble x, y;

    if (gdk_event_get_coords(event, &x, &y))
        return Py_BuildValue("(dd)", x, y);
    else
        return Py_BuildValue("()");
}
%%
override gdk_event_get_root_coords noargs
static PyObject *
_wrap_gdk_event_get_root_coords(PyGObject *self)
{
    GdkEvent *event = pyg_boxed_get(self, GdkEvent);
    gdouble x, y;

    if (gdk_event_get_root_coords(event, &x, &y))
        return Py_BuildValue("(dd)", x, y);
    else
        return Py_BuildValue("()");
}
%%
override-attr GdkDevice.axes
static PyObject *
_wrap_gdk_device__get_axes(PyGObject *self, void *closure)
{
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyObject *ret;
    gint i;

    ret = PyTuple_New(device->num_axes);
    for (i = 0; i < device->num_axes; i++)
        PyTuple_SetItem(ret, i, Py_BuildValue("(idd)",
                                              device->axes[i].use,
                                              device->axes[i].min,
                                              device->axes[i].max));
    return ret;
}
%%
override-attr GdkDevice.keys
static PyObject *
_wrap_gdk_device__get_keys(PyGObject *self, void *closure)
{
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyObject *ret;
    gint i;

    ret = PyTuple_New(device->num_keys);
    for (i = 0; i < device->num_keys; i++)
        PyTuple_SetItem(ret, i, Py_BuildValue("(ii)",
                                              device->keys[i].keyval,
                                              device->keys[i].modifiers));
    return ret;
}
%%
override gdk_device_get_state kwargs
static PyObject *
_wrap_gdk_device_get_state(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    gdouble *axes;
    GdkModifierType mask;
    PyObject *py_axes;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkDevice.get_state",
                                     kwlist, &window))
        return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
        PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
        return NULL;
    }
    axes = g_new0(gdouble, device->num_axes);
    gdk_device_get_state(device, GDK_WINDOW(window->obj), axes, &mask);
    py_axes = PyTuple_New(device->num_axes);
    for (i = 0; i < device->num_axes; i++)
        PyTuple_SetItem(py_axes, i, PyFloat_FromDouble(axes[i]));
    g_free(axes);
    return Py_BuildValue("(Ni)", py_axes, mask);
}
%%
ignore gdk_device_free_history
%%
override gdk_device_get_history kwargs
static PyObject *
_wrap_gdk_device_get_history(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "start", "stop", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyGObject *window;
    guint start, stop;
    GdkTimeCoord **events;
    gint n_events;
    PyObject *pyevents;
    guint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oii:GdkDevice.get_history", kwlist,
                                     &window, &start, &stop))
        return NULL;
    if (!pygobject_check(window, &PyGdkWindow_Type)) {
        PyErr_SetString(PyExc_TypeError, "window should be a GdkWindow");
        return NULL;
    }
    gdk_device_get_history(device, GDK_WINDOW(window->obj), start, stop,
                           &events, &n_events);
    pyevents = PyTuple_New(n_events);
    for (i = 0; i < n_events; i++) {
        PyObject *axes;
        gint j;

        axes = PyTuple_New(device->num_axes);
        for (j = 0; j < device->num_axes; j++)
            PyTuple_SetItem(axes, j, PyFloat_FromDouble(events[i]->axes[j]));
        PyTuple_SetItem(pyevents, i, Py_BuildValue("(iN)", events[i]->time,
                                                   axes));
    }
    gdk_device_free_history(events, n_events);
    return pyevents;
}
%%
override gdk_device_get_axis kwargs
static PyObject *
_wrap_gdk_device_get_axis(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "axes", "use", NULL };
    GdkDevice *device = GDK_DEVICE(self->obj);
    PyObject *py_axes;
    gdouble *axes, value;
    GdkAxisUse use;
    gboolean ret;
    gint i;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:GdkDevice.get_axis",
                                     kwlist, &py_axes, &use))
        return NULL;
    if (!PySequence_Check(py_axes)) {
        PyErr_SetString(PyExc_TypeError, "axes must be a sequence");
        return NULL;
    }
    if (PySequence_Length(py_axes) != device->num_axes) {
        PyErr_SetString(PyExc_TypeError, "axes has the wrong length");
        return NULL;
    }
    axes = g_new(gdouble, device->num_axes);
    for (i = 0; i < device->num_axes; i++) {
        PyObject *item = PySequence_GetItem(py_axes, i);

        axes[i] = PyFloat_AsDouble(item);
        Py_DECREF(item);
        if (PyErr_Occurred()) {
            g_free(axes);
            return NULL;
       }
    }
    ret = gdk_device_get_axis(device, axes, use, &value);
    g_free(axes);
    if (ret)
        return PyFloat_FromDouble(value);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_drag_find_window kwargs
static PyObject *
_wrap_gdk_drag_find_window(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drag_window", "x_root", "y_root", NULL };
    PyGObject *drag_window;
    gint x_root, y_root;
    GdkWindow *dest_window;
    GdkDragProtocol protocol;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oii:GdkDragContext.drag_find_window",
                                     kwlist, &drag_window, &x_root, &y_root))
        return NULL;
    if (!pygobject_check(drag_window, &PyGdkWindow_Type)) {
        PyErr_SetString(PyExc_TypeError, "drag_window must be a GdkWindow");
        return NULL;
    }
    gdk_drag_find_window(GDK_DRAG_CONTEXT(self->obj),
                         GDK_WINDOW(drag_window->obj), x_root, y_root,
                         &dest_window, &protocol);
    return Py_BuildValue("(Ni)", pygobject_new((GObject *)dest_window),
                         protocol);
}
%%
override gdk_drag_find_window_for_screen kwargs
static PyObject *
_wrap_gdk_drag_find_window_for_screen(PyGObject *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "drag_window", "screen", "x_root", "y_root", NULL };
    PyGObject *drag_window, *screen;
    gint x_root, y_root;
    GdkWindow *dest_window;
    GdkDragProtocol protocol;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
			"O!O!ii:GdkDragContext.drag_find_window_for_screen",
			kwlist, &PyGdkWindow_Type, &drag_window,
			&PyGdkScreen_Type, &screen,
			&x_root, &y_root))
        return NULL;
    gdk_drag_find_window_for_screen(GDK_DRAG_CONTEXT(self->obj),
				    GDK_WINDOW(drag_window->obj),
				    GDK_SCREEN(screen->obj),
				    x_root, y_root,
				    &dest_window, &protocol);
    return Py_BuildValue("(Ni)", pygobject_new((GObject *)dest_window),
                         protocol);
}
%%
override-attr GdkDragContext.targets
static PyObject *
_wrap_gdk_drag_context__get_targets(PyGObject *self, void *closure)
{
    PyObject *atom, *ret = PyList_New(0);
    GList *tmp;
    if (ret == NULL)
        return NULL;
    for (tmp = GDK_DRAG_CONTEXT(self->obj)->targets; tmp; tmp = tmp->next) {
        if ((atom = PyGdkAtom_New(GDK_POINTER_TO_ATOM(tmp->data))) == NULL) {
            Py_DECREF(ret);
            return NULL;
        }
        PyList_Append(ret, atom);
        Py_DECREF(atom);
    }
    return ret;
}
%%
override gdk_gc_new_with_values kwargs
static PyObject *
_wrap_gdk_gc_new_with_values(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreground", "background", "font", "function",
                              "fill", "tile", "stipple", "clip_mask",
                              "subwindow_mode", "ts_x_origin", "ts_y_origin",
                              "clip_x_origin", "clip_y_origin",
                              "graphics_exposures", "line_width", "line_style",
                              "cap_style", "join_style", NULL };
    PyObject *foreground = Py_None, *background = Py_None;
    PyObject *font = Py_None;
    gint function = -1, fill = -1;
    PyObject *tile = Py_None, *stipple = Py_None, *clip_mask = Py_None;
    gint subwindow_mode = -1, ts_x_origin = -1, ts_y_origin = -1;
    gint clip_x_origin = -1, clip_y_origin = -1, graphics_exposures = -1;
    gint line_width = -1, line_style = -1, cap_style = -1, join_style = -1;
    GdkGCValues values;
    GdkGCValuesMask mask = 0;
    GdkGC *gc;
    PyObject *pygc;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OOOiiOOOiiiiiiiiii:GdkDrawable.new_gc",
                                     kwlist, &foreground, &background, &font,
                                     &function, &fill, &tile, &stipple,
                                     &clip_mask, &subwindow_mode,
                                     &ts_x_origin, &ts_y_origin,
                                     &clip_x_origin, &clip_y_origin,
                                     &graphics_exposures, &line_width,
                                     &line_style, &cap_style, &join_style))
        return NULL;
    if (pyg_boxed_check(foreground, GDK_TYPE_COLOR)) {
        mask |= GDK_GC_FOREGROUND;
        values.foreground = *pyg_boxed_get(foreground, GdkColor);
    } else if (foreground != Py_None) {
        PyErr_SetString(PyExc_TypeError, "foreground must be a GdkColor");
        return NULL;
    }
    if (pyg_boxed_check(background, GDK_TYPE_COLOR)) {
        mask |= GDK_GC_BACKGROUND;
        values.background = *pyg_boxed_get(background, GdkColor);
    } else if (background != Py_None) {
        PyErr_SetString(PyExc_TypeError, "background must be a GdkColor");
        return NULL;
    }
    if (pyg_boxed_check(font, GDK_TYPE_FONT)) {
        mask |= GDK_GC_FONT;
        values.font = pyg_boxed_get(font, GdkFont);
    } else if (font != Py_None) {
        PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
        return NULL;
    }
    if (function != -1) {
        mask |= GDK_GC_FUNCTION;
        values.function = function;
    }
    if (fill != -1) {
        mask |= GDK_GC_FILL;
        values.fill = fill;
    }
    if (pygobject_check(tile, &PyGdkPixmap_Type)) {
        mask |= GDK_GC_TILE;
        values.tile = GDK_PIXMAP(pygobject_get(tile));
    } else if (tile != Py_None) {
        PyErr_SetString(PyExc_TypeError, "tile must be a GdkPixmap");
        return NULL;
    }
    if (pygobject_check(stipple, &PyGdkPixmap_Type)) {
        mask |= GDK_GC_STIPPLE;
        values.stipple = GDK_PIXMAP(pygobject_get(stipple));
    } else if (stipple != Py_None) {
        PyErr_SetString(PyExc_TypeError, "stipple must be a GdkPixmap");
        return NULL;
    }
    if (pygobject_check(clip_mask, &PyGdkPixmap_Type)) {
        mask |= GDK_GC_CLIP_MASK;
        values.clip_mask = GDK_PIXMAP(pygobject_get(clip_mask));
    } else if (clip_mask != Py_None) {
        PyErr_SetString(PyExc_TypeError, "clip_mask must be a GdkPixmap");
        return NULL;
    }
    if (subwindow_mode != -1) {
        mask |= GDK_GC_SUBWINDOW;
        values.subwindow_mode = subwindow_mode;
    }
    if (ts_x_origin != -1) {
        mask |= GDK_GC_TS_X_ORIGIN;
        values.ts_x_origin = ts_x_origin;
    }
    if (ts_y_origin != -1) {
        mask |= GDK_GC_TS_Y_ORIGIN;
        values.ts_y_origin = ts_y_origin;
    }
    if (clip_x_origin != -1) {
        mask |= GDK_GC_CLIP_X_ORIGIN;
        values.clip_x_origin = clip_x_origin;
    }
    if (clip_y_origin != -1) {
        mask |= GDK_GC_CLIP_Y_ORIGIN;
        values.clip_y_origin = clip_y_origin;
    }
    if (graphics_exposures != -1) {
        mask |= GDK_GC_EXPOSURES;
        values.graphics_exposures = graphics_exposures;
    }
    if (line_width != -1) {
        mask |= GDK_GC_LINE_WIDTH;
        values.line_width = line_width;
    }
    if (line_style != -1) {
        mask |= GDK_GC_LINE_STYLE;
        values.line_style = line_style;
    }
    if (cap_style != -1) {
        mask |= GDK_GC_CAP_STYLE;
        values.cap_style = cap_style;
    }
    if (join_style != -1) {
        mask |= GDK_GC_JOIN_STYLE;
        values.join_style = join_style;
    }
    gc = gdk_gc_new_with_values(GDK_DRAWABLE(self->obj), &values, mask);
    pygc = pygobject_new((GObject *)gc);
    gdk_gc_unref(gc);
    return pygc;
}
%%
override-slot GdkGC.tp_getattr
PyObject *
_wrap_gdk_gc_tp_getattr(PyGObject *self, char *attr)
{
    GdkGCValues gc;

    if (!strcmp(attr, "__members__"))
        return Py_BuildValue("[ssssssssssssssssss]", "background", "cap_style",
                             "clip_mask", "clip_x_origin", "clip_y_origin",
                             "fill", "font", "foreground", "function",
                             "graphics_exposures", "join_style", "line_style",
                             "line_width", "stipple", "sub_window", "tile",
                             "ts_x_origin", "ts_y_origin");
    gdk_gc_get_values(GDK_GC(self->obj), &gc);
    if (!strcmp(attr, "foreground")) 
        return pyg_boxed_new(GDK_TYPE_COLOR, &(gc.foreground), TRUE, TRUE);
    if (!strcmp(attr, "background")) 
        return pyg_boxed_new(GDK_TYPE_COLOR, &(gc.background), TRUE, TRUE);
    if (!strcmp(attr, "font")) 
        return pyg_boxed_new(GDK_TYPE_FONT, gc.font, TRUE, TRUE);
    if (!strcmp(attr, "function")) 
        return PyInt_FromLong(gc.function);
    if (!strcmp(attr, "fill")) 
        return PyInt_FromLong(gc.fill);
    if (!strcmp(attr, "tile")) 
        return pygobject_new((GObject *)gc.tile);
    if (!strcmp(attr, "stipple")) 
        return pygobject_new((GObject *)gc.stipple);
    if (!strcmp(attr, "clip_mask")) 
        return pygobject_new((GObject *)gc.clip_mask);
    if (!strcmp(attr, "subwindow_mode"))
        return PyInt_FromLong(gc.subwindow_mode);
    if (!strcmp(attr, "ts_x_origin")) 
        return PyInt_FromLong(gc.ts_x_origin);
    if (!strcmp(attr, "ts_y_origin")) 
        return PyInt_FromLong(gc.ts_y_origin);
    if (!strcmp(attr, "clip_x_origin")) 
        return PyInt_FromLong(gc.clip_x_origin);
    if (!strcmp(attr, "clip_y_origin")) 
        return PyInt_FromLong(gc.clip_y_origin);
    if (!strcmp(attr, "graphics_exposures"))
        return PyInt_FromLong(gc.graphics_exposures);
    if (!strcmp(attr, "line_width")) 
        return PyInt_FromLong(gc.line_width);
    if (!strcmp(attr, "line_style")) 
        return PyInt_FromLong(gc.line_style);
    if (!strcmp(attr, "cap_style")) 
        return PyInt_FromLong(gc.cap_style);
    if (!strcmp(attr, "join_style")) 
        return PyInt_FromLong(gc.join_style);

    {
        PyObject *name = PyString_FromString(attr);
        PyObject *ret = PyObject_GenericGetAttr((PyObject *)self, name);
        Py_DECREF(name);
        return ret;
    }
}
%%
override-slot GdkGC.tp_setattr
static int
_wrap_gdk_gc_tp_setattr(PyGObject *self, char *attr, PyObject *value)
{
    GdkGC *gc = GDK_GC(self->obj);

    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "can't delete attributes");
        return -1;
    }
    if (PyInt_Check(value)) {
        int i = PyInt_AsLong(value);
        GdkGCValues v;
        gdk_gc_get_values(gc, &v);
        if (!strcmp(attr, "function")) {
            gdk_gc_set_function(gc, i);
            return 0;
        } else if (!strcmp(attr, "fill")) {
            gdk_gc_set_fill(gc, i);
            return 0;
        } else if (!strcmp(attr, "subwindow_mode")) {
            gdk_gc_set_subwindow(gc, i);
            return 0;
        } else if (!strcmp(attr, "ts_x_origin")) {
            gdk_gc_set_ts_origin(gc, i, v.ts_y_origin);
            return 0;
        } else if (!strcmp(attr, "ts_y_origin")) {
            gdk_gc_set_ts_origin(gc, v.ts_x_origin, i);
            return 0;
        } else if (!strcmp(attr, "clip_x_origin")) {
            gdk_gc_set_clip_origin(gc, i, v.clip_y_origin);
            return 0;
        } else if (!strcmp(attr, "clip_y_origin")) {
            gdk_gc_set_clip_origin(gc, v.clip_x_origin, i);
            return 0;
        } else if (!strcmp(attr, "graphics_exposures")) {
            gdk_gc_set_exposures(gc, i);
            return 0;
        } else if (!strcmp(attr, "line_width")) {
            gdk_gc_set_line_attributes(gc, i, v.line_style,
                                       v.cap_style, v.join_style);
            return 0;
        } else if (!strcmp(attr, "line_style")) {
            gdk_gc_set_line_attributes(gc, v.line_width, i,
                                       v.cap_style, v.join_style);
            return 0;
        } else if (!strcmp(attr, "cap_style")) {
            gdk_gc_set_line_attributes(gc, v.line_width, v.line_style,
                                       i, v.join_style);
            return 0;
        } else if (!strcmp(attr, "join_style")) {
            gdk_gc_set_line_attributes(gc, v.line_width, v.line_style,
                                       v.cap_style, i);
            return 0;
        }
    } else if (pyg_boxed_check(value, GDK_TYPE_COLOR)) {
        GdkColor *c = pyg_boxed_get(value, GdkColor);
        if (!strcmp(attr, "foreground")) {
            gdk_gc_set_foreground(gc, c);
            return 0;
        } else if (!strcmp(attr, "background")) {
            gdk_gc_set_background(gc, c);
            return 0;
        }
    } else if (pyg_boxed_check(value, GDK_TYPE_FONT)) {
        if (!strcmp(attr, "font")) {
            gdk_gc_set_font(gc, pyg_boxed_get(value, GdkFont));
            return 0;
        }
    } else if (pygobject_check(value, &PyGdkWindow_Type) || value == Py_None) {
        PyGObject *window = (PyGObject *)value;
        GdkWindow *w = (value==Py_None)?NULL:GDK_WINDOW(window->obj);
        if (!strcmp(attr, "tile")) {
            gdk_gc_set_tile(gc, w);
            return 0;
        } else if (!strcmp(attr, "stipple")) {
            gdk_gc_set_stipple(gc, w);
            return 0;
        } else if (!strcmp(attr, "clip_mask")) {
            gdk_gc_set_clip_mask(gc, w);
            return 0;
        }
    }

    PyErr_SetString(PyExc_AttributeError, "could not write attribute");
    return -1;
}
%%
override gdk_gc_set_dashes
static PyObject *
_wrap_gdk_gc_set_dashes(PyGObject *self, PyObject *args)
{
    gint dash_offset, n, i;
    PyObject *list;
    guchar *dash_list;

    if (!PyArg_ParseTuple(args, "iO:GdkGC.set_dashes", &dash_offset, &list))
        return NULL;
    if (!PySequence_Check(list)) {
        PyErr_SetString(PyExc_TypeError, "second argument must be a sequence");
        return NULL;
    }
    n = PySequence_Length(list);
    dash_list = g_new(char, n);
    for (i = 0; i < n; i++) {
        PyObject *item = PySequence_GetItem(list, i);
        Py_DECREF(item);

        if (!PyInt_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "sequence member must be an int");
            g_free(dash_list);
            return NULL;
        }
        dash_list[i] = (guchar)PyInt_AsLong(item);
        if (dash_list[i] == 0) {
            PyErr_SetString(PyExc_TypeError, "sequence member must not be 0");
            g_free(dash_list);
            return NULL;
        }
    }
    gdk_gc_set_dashes(GDK_GC(self->obj), dash_offset, dash_list, n);
    g_free(dash_list);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_drawable_get_size noargs
static PyObject *
_wrap_gdk_drawable_get_size(PyGObject *self)
{
    gint width;
    gint height;

    gdk_drawable_get_size(GDK_DRAWABLE(self->obj), &width, &height);
    return Py_BuildValue("(ii)", width, height);
}
%%
override gdk_drag_begin kwargs
static PyObject *
_wrap_gdk_drag_begin(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "targets", NULL };
    PyObject *py_targets;
    GList *targets = NULL;
    guint i, len;
    GdkDragContext *context;
    PyObject *py_context;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkWindow.drag_begin",
                                     kwlist, &py_targets))
        return NULL;
    if (!PySequence_Check(py_targets)) {
        PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
        return NULL;
    }
    len = PySequence_Length(py_targets);
    for (i = 0; i < len; i++) {
        PyObject *item = PySequence_GetItem(py_targets, i);

        if (PyInt_Check(item)) {
            targets = g_list_append(targets,
                                    GUINT_TO_POINTER(PyInt_AsLong(item)));
            Py_DECREF(item);
        } else {
            PyErr_SetString(PyExc_TypeError, "targets must be a list of ints");
            Py_DECREF(item);
            g_list_free(targets);
            return NULL;
        }
    }
    context = gdk_drag_begin(GDK_WINDOW(self->obj), targets);
    g_list_free(targets);
    py_context = pygobject_new((GObject *)context);
    gdk_drag_context_unref(context);
    return py_context;
}
%%
override gdk_property_get kwargs

static GdkAtom atom_type = GDK_NONE, atom_pair_type = GDK_NONE;

static PyObject *
_wrap_gdk_property_get(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property", "type", "pdelete", NULL };
    PyObject *py_property, *py_type = NULL;
    GdkAtom property, type;
    gint pdelete = FALSE;

    GdkAtom atype;
    gint aformat, alength;
    guchar *data;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|Oi:GdkWindow.property_get", kwlist,
                                     &py_property, &py_type, 
                                     &pdelete)) {
        return NULL;
    }
    property = pygdk_atom_from_pyobject(py_property);
    if (PyErr_Occurred())
        return NULL;

    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;

    if (gdk_property_get(GDK_WINDOW(self->obj), property, type, 0, 9999,
                         pdelete, &atype, &aformat, &alength, &data)) {
        /* success */
        PyObject *pdata = NULL;
        gint nelements, i;
        switch (aformat) {
        case 8:
            if ((pdata = PyString_FromStringAndSize(data, alength)) == NULL)
                return NULL;
            break;
        case 16: {
            short *data16;

            data16 = (short *)data;
            nelements = alength / sizeof(short);
            if ((pdata = PyList_New(nelements)) == NULL)
                return NULL;
            for (i = 0; i < nelements; i++)
                PyList_SetItem(pdata, i, PyInt_FromLong(data16[i]));
            break;
        }
        case 32: {
            if (atom_type == GDK_NONE) {
                atom_type = gdk_atom_intern("ATOM", TRUE);
                atom_pair_type = gdk_atom_intern("ATOM_PAIR", TRUE);
            }

            /* special handling for atom types */
            if (atype == atom_type || atype == atom_pair_type) {
                GdkAtom *data32;

                data32 = (GdkAtom *)data;
                nelements = alength / sizeof(GdkAtom);
                if ((pdata = PyList_New(nelements)) == NULL)
                    return NULL;
                for (i = 0; i < nelements; i++)
                    PyList_SetItem(pdata, i, PyGdkAtom_New(data32[i]));
            } else {
                long *data32;

                data32 = (long *)data;
                nelements  = alength / sizeof(long);
                if ((pdata = PyList_New(nelements)) == NULL)
                    return NULL;
                for (i = 0; i < nelements; i++)
                    PyList_SetItem(pdata, i, PyInt_FromLong(data32[i]));
            }
            break;
        }
        default:
            g_warning("got a property format != 8, 16 or 32");
            g_assert_not_reached();
        }
        g_free(data);
        return Py_BuildValue("(NiN)", PyGdkAtom_New(atype), aformat, pdata);
    } else {
        Py_INCREF(Py_None);
        return Py_None;
    }
}
%%
override gdk_property_change kwargs
static PyObject *
_wrap_gdk_property_change(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "property","type","format","mode","data",NULL };
    PyObject *py_property, *py_type;
    GdkAtom property, type;
    gint format;
    PyObject *py_mode, *pdata;
    GdkPropMode mode;
    guchar *data = NULL;
    gint nelements;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OOiOO:GdkWindow.property_change", kwlist,
                                     &py_property, &py_type, &format, &py_mode,
                                     &pdata)) {
        return NULL;
    }
    property = pygdk_atom_from_pyobject(py_property);
    if (PyErr_Occurred())
        return NULL;

    type = pygdk_atom_from_pyobject(py_type);
    if (PyErr_Occurred())
        return NULL;
    
    if (pyg_enum_get_value(GDK_TYPE_PROP_MODE, py_mode, (gint *)&mode))
        return NULL;
    switch (format) {
    case 8:
        if (!PyString_Check(pdata)) {
            PyErr_SetString(PyExc_TypeError, "data not a string and format=8");
            return NULL;
        }
        data = PyString_AsString(pdata);
        nelements = PyString_Size(pdata);
        break;
    case 16: {
        short *data16;
        gint i;

        if (!PySequence_Check(pdata)) {
            PyErr_SetString(PyExc_TypeError,
                            "data not a sequence and format=16");
            return NULL;
        }
        nelements = PySequence_Length(pdata);
        data16 = g_new(short, nelements);
        data = (guchar *)data16;
        for (i = 0; i < nelements; i++) {
            PyObject *item = PySequence_GetItem(pdata, i);

            if (item) data16[i] = PyInt_AsLong(item);
            if (!item || PyErr_Occurred()) {
                Py_XDECREF(item);
                g_free(data16);
                PyErr_Clear();
                PyErr_SetString(PyExc_TypeError,"data element not an int");
                return NULL;
            }
            Py_DECREF(item);
        }
        break;
    }
    case 32: {
        gint i;

        if (!PySequence_Check(pdata)) {
            PyErr_SetString(PyExc_TypeError,
                            "data not a sequence and format=32");
            return NULL;
        }
        nelements = PySequence_Length(pdata);

        if (atom_type == GDK_NONE) {
            atom_type = gdk_atom_intern("ATOM", TRUE);
            atom_pair_type = gdk_atom_intern("ATOM_PAIR", TRUE);
        }

        /* special handling for atom types */
        if (type == atom_type || type == atom_pair_type) {
            GdkAtom *data32 = g_new(GdkAtom, nelements);

            data = (guchar *)data32;
            for (i = 0; i < nelements; i++) {
                PyObject *item = PySequence_GetItem(pdata, i);

                if (item) data32[i] = pygdk_atom_from_pyobject(item);
                if (!item || PyErr_Occurred()) {
                    Py_XDECREF(item);
                    g_free(data32);
                    PyErr_Clear();
                    PyErr_SetString(PyExc_TypeError,"data element not an atom");
                    return NULL;
                }
                Py_DECREF(item);
            }
        } else {
            long *data32 = g_new(long, nelements);

            data = (guchar *)data32;
            for (i = 0; i < nelements; i++) {
                PyObject *item = PySequence_GetItem(pdata, i);

                if (item) data32[i] = PyInt_AsLong(item);
                if (!item || PyErr_Occurred()) {
                    Py_XDECREF(item);
                    g_free(data32);
                    PyErr_Clear();
                    PyErr_SetString(PyExc_TypeError,"data element not an int");
                    return NULL;
                }
                Py_DECREF(item);
            }
        }
        break;
    }
    default:
        PyErr_SetString(PyExc_TypeError, "format must be 8, 16 or 32");
        return NULL;
        break;
    }
    gdk_property_change(GDK_WINDOW(self->obj), property, type, format, mode,
                        data, nelements);
    if (format != 8)
        g_free(data);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_window_set_geometry_hints kwargs
static PyObject *
_wrap_gdk_window_set_geometry_hints(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "min_width", "min_height",
                              "max_width", "max_height", "base_width",
                              "base_height", "width_inc", "height_inc",
                              "min_aspect", "max_aspect", NULL };
    gint min_width = -1, min_height = -1, max_width = -1, max_height = -1;
    gint base_width = -1, base_height = -1, width_inc = -1, height_inc = -1;
    gdouble min_aspect = -1.0, max_aspect = -1.0;
    GdkGeometry geometry = { 0 };
    GdkWindowHints geom_mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|iiiiiiidd:GdkWindow.set_geometry_hints",
				     kwlist, &min_width, &min_height,
				     &max_width, &max_height,
                                     &base_width, &base_height, &width_inc,
                                     &height_inc, &min_aspect, &max_aspect))
        return NULL;
    if (min_width >= 0 || min_height >= 0) {
        geometry.min_width = MAX(min_width, 0);
        geometry.min_height = MAX(min_height, 0);
        geom_mask |= GDK_HINT_MIN_SIZE;
    }
    if (max_width >= 0 || max_height >= 0) {
        geometry.max_width = MAX(max_width, 0);
        geometry.max_height = MAX(max_height, 0);
        geom_mask |= GDK_HINT_MAX_SIZE;
    }
    if (base_width >= 0 || base_height >= 0) {
        geometry.base_width = MAX(base_width, 0);
        geometry.base_height = MAX(base_height, 0);
        geom_mask |= GDK_HINT_BASE_SIZE;
    }
    if (width_inc >= 0 || height_inc >= 0) {
        geometry.width_inc = MAX(width_inc, 0);
        geometry.height_inc = MAX(height_inc, 0);
        geom_mask |= GDK_HINT_RESIZE_INC;
    }
    if (min_aspect >= 0.0 || max_aspect >= 0.0) {
        if (min_aspect <= 0.0 || max_aspect <= 0.0) {
            PyErr_SetString(PyExc_TypeError, "aspect ratios must be positive");
            return NULL;
        }
        geometry.min_aspect = min_aspect;
        geometry.max_aspect = max_aspect;
        geom_mask |= GDK_HINT_ASPECT;
    }
    gdk_window_set_geometry_hints(GDK_WINDOW(self->obj), &geometry, geom_mask);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_window_get_geometry noargs
static PyObject *
_wrap_gdk_window_get_geometry(PyGObject *self)
{
    gint x, y, width, height, depth;

    gdk_window_get_geometry(GDK_WINDOW(self->obj), &x, &y, &width, &height,
                            &depth);
    return Py_BuildValue("(iiiii)", x, y, width, height, depth);
}
%%
override gdk_window_get_position noargs
static PyObject *
_wrap_gdk_window_get_position(PyGObject *self)
{
    gint x, y;

    gdk_window_get_position(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_origin noargs
static PyObject *
_wrap_gdk_window_get_origin(PyGObject *self)
{
    gint x, y;

    gdk_window_get_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_deskrelative_origin noargs
static PyObject *
_wrap_gdk_window_get_deskrelative_origin(PyGObject *self)
{
    gint x, y;

    gdk_window_get_deskrelative_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_root_origin noargs
static PyObject *
_wrap_gdk_window_get_root_origin(PyGObject *self)
{
    gint x, y;

    gdk_window_get_root_origin(GDK_WINDOW(self->obj), &x, &y);
    return Py_BuildValue("(ii)", x, y);
}
%%
override gdk_window_get_pointer noargs
static PyObject *
_wrap_gdk_window_get_pointer(PyGObject *self)
{
    gint x, y;
    GdkModifierType mask;

    gdk_window_get_pointer(GDK_WINDOW(self->obj), &x, &y, &mask);
    return Py_BuildValue("(iii)", x, y, (gint)mask);
}
%%
ignore gdk_window_peek_children
%%
override gdk_window_get_children noargs
static PyObject *
_wrap_gdk_window_get_children(PyGObject *self)
{
    GList *children, *tmp;
    PyObject *list;

    children = gdk_window_get_children(GDK_WINDOW(self->obj));
    list = PyList_New(0);
    for (tmp = children; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new((GObject *)tmp->data);

        PyList_Append(list, item);
        Py_DECREF(item);
    }
    g_list_free(children);
    return list;
}
%%
override gdk_window_set_icon_list kwargs
static PyObject *
_wrap_gdk_window_set_icon_list(PyGObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "pixbufs", NULL };
    PyObject *py_pixbufs;
    gint length, i;
    GList *pixbufs = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkWindow.set_icon_list",
				     kwlist, &py_pixbufs))
	return NULL;
    if (!(py_pixbufs = PySequence_Fast(py_pixbufs,
				"pixbufs must be a sequence of pixbufs")))
	return NULL;
    length = PySequence_Fast_GET_SIZE(py_pixbufs);
    for (i = length - 1; i >= 0; i--) {
	PyObject *item = PySequence_Fast_GET_ITEM(py_pixbufs, i);

	if (!pygobject_check(item, &PyGdkPixbuf_Type)) {
	    g_list_free(pixbufs);
	    Py_DECREF(py_pixbufs);
	    PyErr_SetString(PyExc_TypeError,
			    "pixbufs must be a sequence of pixbufs");
	    return NULL;
	}
	pixbufs = g_list_prepend(pixbufs, GDK_PIXBUF(pygobject_get(item)));
    }
    gdk_window_set_icon_list(GDK_WINDOW(self->obj), pixbufs);
    g_list_free(pixbufs);
    Py_DECREF(py_pixbufs);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_pixbuf_render_pixmap_and_mask kwargs
static PyObject *
_wrap_gdk_pixbuf_render_pixmap_and_mask(PyGObject *self, PyObject *args,
                                        PyObject *kwargs)
{
    static char *kwlist[] = { "alpha_threshold", NULL};
    int alpha_threshold = 127;
    GdkPixmap *pixmap;
    GdkBitmap *mask;
    PyObject *pypixmap, *pymask, *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|i:GdkPixbuf.render_pixmap_and_mask", kwlist,
                                     &alpha_threshold))
        return NULL;
    gdk_pixbuf_render_pixmap_and_mask(GDK_PIXBUF(self->obj), &pixmap, &mask,
                                      alpha_threshold);

    if (pixmap) {
        pypixmap = pygobject_new((GObject *) pixmap);
        gdk_pixmap_unref(pixmap);
    } else {
        Py_INCREF(Py_None);
        pypixmap = Py_None;
    }

    if (mask) {
        pymask = pygobject_new((GObject *) mask);
        gdk_bitmap_unref(mask);
    } else {
        Py_INCREF(Py_None);
        pymask = Py_None;
    }
    
    ret = Py_BuildValue("(NN)", pypixmap, pymask);
    return ret;
}
%%
override-attr GdkPixbuf.pixel_array
#ifdef HAVE_NUMPY
static int
have_numpy(void)
{
    /* Return 1 if Numeric is available,
       return 0 and set and exception if it is not. */
    static int import_done = 0;
    static PyObject *exc_type=NULL, *exc_value=NULL;
    PyObject *exc_tb=NULL;

    if (exc_type != NULL) {
	PyErr_Restore(exc_type, exc_value, NULL);
	return 0;
    }
    if (!import_done) {
	import_done = 1;
	import_array();
	if (PyErr_Occurred()) {
	    PyErr_Fetch(&exc_type, &exc_value, &exc_tb);
	    Py_INCREF(exc_type);
	    Py_XINCREF(exc_value);
	    PyErr_Restore(exc_type, exc_value, exc_tb);
	    return 0;
	}
    }
    return 1;
}
#endif
static PyObject *
_wrap_gdk_pixbuf__get_pixel_array(PyGObject *self, void *closure)
{
    PyErr_Warn(PyExc_DeprecationWarning, "use pixbuf.get_pixels_array() instead of the pixbuf.pixel_array attribute");
    return _wrap_gdk_pixbuf_get_pixels_array(self);
}
%%
define GdkPixbuf.get_pixels_array noargs
static PyObject *
_wrap_gdk_pixbuf_get_pixels_array(PyGObject *self)
{


#ifdef HAVE_NUMPY
    GdkPixbuf *pixbuf = GDK_PIXBUF(self->obj);
    PyArrayObject *array;
    int dims[3] = { 0, 0, 3 };

    if (!have_numpy())
	return NULL;

    dims[0] = gdk_pixbuf_get_height(pixbuf);
    dims[1] = gdk_pixbuf_get_width(pixbuf);
    if (gdk_pixbuf_get_has_alpha(pixbuf))
        dims[2] = 4;
    array = (PyArrayObject *)PyArray_FromDimsAndData(3, dims, PyArray_UBYTE,
                                        (char *)gdk_pixbuf_get_pixels(pixbuf));
    if (array == NULL)
        return NULL;

    array->strides[0] = gdk_pixbuf_get_rowstride(pixbuf);
    /* the array holds a ref to the pixbuf pixels through this wrapper*/
    Py_INCREF(self);
    array->base = (PyObject *)self;
    return PyArray_Return(array);
#else
    PyErr_SetString(PyExc_RuntimeError, "pygtk was not compiled with Numeric Python support");
    return NULL;
#endif
}
%%
override gdk_pixbuf_get_pixels noargs
static PyObject *
_wrap_gdk_pixbuf_get_pixels(PyGObject *self)
{
    GdkPixbuf *pixbuf;
    guchar *pixels;
    gint rowstride, height;

    pixbuf = GDK_PIXBUF(self->obj);
    pixels = gdk_pixbuf_get_pixels(pixbuf);
    rowstride = gdk_pixbuf_get_rowstride(pixbuf);
    height = gdk_pixbuf_get_height(pixbuf);

    if (pixels == NULL) {
        PyErr_SetString(PyExc_ValueError, "could not get pixel data");
        return NULL;
    }

    return PyString_FromStringAndSize(pixels, rowstride*height);
}
%%
override gdk_pixbuf_save kwargs
static PyObject *
_wrap_gdk_pixbuf_save(PyGObject *self, PyObject *args,
                      PyObject *kwargs)
{
    static char *kwlist[] = {"filename", "type", "options", NULL};
    gchar *filename, *type, **option_keys = NULL, **option_values = NULL;
    PyObject *py_options = NULL;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ss|O!:GdkPixbuf.save", kwlist,
                                     &filename, &type,
                                     &PyDict_Type, &py_options))
        return NULL;

    if (py_options != NULL) {
        guint len;
        gint pos = 0, i = 0;
        PyObject *key, *value;
        
        len = PyDict_Size(py_options);
        option_keys = g_new(gchar *, len + 1);
        option_values = g_new(gchar *, len + 1);

        while (PyDict_Next(py_options, &pos, &key, &value)) {
            if (!PyString_Check(key) || !PyString_Check(value)) {
                g_free(option_keys);
                g_free(option_values);
                PyErr_SetString(PyExc_TypeError,
                                "keys and values must be strings");
                return NULL;
            }

            option_keys[i]   = PyString_AsString(key);
            option_values[i] = PyString_AsString(value);
            i++;
        }
        
        option_keys[len] = NULL;
        option_values[len] = NULL;
    }
    gdk_pixbuf_savev(GDK_PIXBUF(self->obj), filename, type,
                     option_keys, option_values, &error);
        
    g_free(option_keys);
    g_free(option_values);
 
    if (pyg_error_check(&error))
        return NULL;
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_colormap_alloc_color kwargs
static PyObject *
_wrap_gdk_colormap_alloc_color(PyGObject *self, PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist1[] = { "red", "green", "blue", "writeable", "best_match", NULL };
    static char *kwlist2[] = { "spec", "writeable", "best_match", NULL };
    static char *kwlist3[] = { "color", "writeable", "best_match", NULL };
    GdkColor colour = { 0, 0, 0, 0 };
    gboolean writeable = FALSE;
    gboolean best_match = TRUE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "HHH|ii:GdkColormap.alloc_color", kwlist1,
                                     &colour.red, &colour.green, &colour.blue,
                                     &writeable, &best_match)) {

 	PyObject *pycolour;
	
        PyErr_Clear();
        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
 					 "O|ii:GdkColormap.alloc_color",
 					 kwlist3, &pycolour,
 					 &writeable, &best_match)) {
            return NULL;
	}

 	if (!pyg_boxed_check(pycolour, GDK_TYPE_COLOR)) {
 	    gchar *color_name;
 
 	    PyErr_Clear();
 	    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
 					     "s|ii:GdkColormap.alloc_color",
 					     kwlist2, &color_name, &writeable,
 					     &best_match)) {
 		return NULL;
	    }
	    
 	    if (!gdk_color_parse(color_name, &colour)) {
 		PyErr_SetString(PyExc_TypeError,
 				"unable to parse colour specification");
 		return NULL;
	    }
 	} else {
 	    colour = *pyg_boxed_get(pycolour, GdkColor);
        }
    }
    
    if (!gdk_colormap_alloc_color(GDK_COLORMAP(self->obj),
                                  &colour, writeable, best_match)) {
        PyErr_SetString(PyExc_RuntimeError, "couldn't allocate colour");
        return NULL;
    }
    return pyg_boxed_new(GDK_TYPE_COLOR, &colour, TRUE, TRUE);
}
%%
override gdk_color_alloc kwargs
static PyObject *
_wrap_gdk_color_alloc(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    if (!PyErr_Warn(PyExc_DeprecationWarning, "use GdkColormap.alloc_color")<0)
        return NULL;
    return _wrap_gdk_colormap_alloc_color(self, args, kwargs);
}
%%
override-slot GdkRectangle.tp_as_sequence
static int
_wrap_gdk_rectangle_length(PyGBoxed *self)
{
    return 4;
}
static PyObject *
_wrap_gdk_rectangle_getitem(PyGBoxed *self, int pos)
{
    GdkRectangle *rect;

    if (pos < 0) pos += 4;
    if (pos < 0 || pos >= 4) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }
    rect = pyg_boxed_get(self, GdkRectangle);
    switch (pos) {
    case 0: return PyInt_FromLong(rect->x);
    case 1: return PyInt_FromLong(rect->y);
    case 2: return PyInt_FromLong(rect->width);
    case 3: return PyInt_FromLong(rect->height);
    default:
        g_assert_not_reached();
        return NULL;
    }
}
static int
_wrap_gdk_rectangle_setitem(PyGBoxed *self, int pos, PyObject *value)
{
    GdkRectangle *rect;
    gint val;

    if (pos < 0) pos += 4;
    if (pos < 0 || pos >= 4) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    rect = pyg_boxed_get(self, GdkRectangle);
    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    switch(pos) {
    case 0: rect->x      = val; break;
    case 1: rect->y      = val; break;
    case 2: rect->width  = val; break;
    case 3: rect->height = val; break;
    default:
        g_assert_not_reached();
        return -1;
    }
    return 0;
}
static PySequenceMethods _wrap_gdk_rectangle_tp_as_sequence = {
    (inquiry)_wrap_gdk_rectangle_length,
    (binaryfunc)0,
    (intargfunc)0,
    (intargfunc)_wrap_gdk_rectangle_getitem,
    (intintargfunc)0,
    (intobjargproc)_wrap_gdk_rectangle_setitem,
    (intintobjargproc)0
};
%%
override-attr GdkRectangle.x
static int
_wrap_gdk_rectangle__set_x(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GdkRectangle)->x = val;
    return 0;
}
%%
override-attr GdkRectangle.y
static int
_wrap_gdk_rectangle__set_y(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GdkRectangle)->y = val;
    return 0;
}
%%
override-attr GdkRectangle.width
static int
_wrap_gdk_rectangle__set_width(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GdkRectangle)->width = val;
    return 0;
}
%%
override-attr GdkRectangle.height
static int
_wrap_gdk_rectangle__set_height(PyGBoxed *self, PyObject *value, void *closure)
{
    gint val;

    val = PyInt_AsLong(value);
    if (PyErr_Occurred())
        return -1;
    pyg_boxed_get(self, GdkRectangle)->height = val;
    return 0;
}
%%
override gdk_rectangle_intersect kwargs
static PyObject *
_wrap_gdk_rectangle_intersect(PyGObject *self, PyObject *args,
			      PyObject *kwargs)
{
    static char *kwlist[] = { "src", NULL };
    PyObject *py_src;
    GdkRectangle src, dest = {0, 0, 0, 0};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkRectangle.intersect",
				     kwlist, &py_src)) {
        return NULL;
    }
    
    if (!pyg_boxed_check(py_src, GDK_TYPE_RECTANGLE)) {
	if (!pygdk_rectangle_from_pyobject(py_src, &src)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "src must be a GdkRectangle or 4-tuple");
	    return NULL;
	}
    } else {
	src = *pyg_boxed_get(py_src, GdkRectangle);
    }

    gdk_rectangle_intersect(pyg_boxed_get(self, GdkRectangle), &src, &dest);
                            
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE);
}
%%
override gdk_rectangle_union kwargs
static PyObject *
_wrap_gdk_rectangle_union(PyGObject *self, PyObject *args,
			  PyObject *kwargs)
{
    static char *kwlist[] = { "src", NULL };
    PyObject *py_src;
    GdkRectangle src, dest;
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkRectangle.union",
				     kwlist, &py_src)) {
        return NULL;
    }
    
    if (!pyg_boxed_check(py_src, GDK_TYPE_RECTANGLE)) {
	if (!pygdk_rectangle_from_pyobject(py_src, &src)) {
	    PyErr_Clear();
	    PyErr_SetString(PyExc_TypeError,
			    "src must be a GdkRectangle or 4-tuple");
	    return NULL;
	}
    } else {
	src = *pyg_boxed_get(py_src, GdkRectangle);
    }

    gdk_rectangle_union(pyg_boxed_get(self, GdkRectangle), &src, &dest);
                            
    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE);
}
%%
override gdk_pixbuf_new_from_data kwargs
static PyObject *
_wrap_gdk_pixbuf_new_from_data(PyObject *self, PyObject *args,
			       PyObject *kwargs)
{
    static char *kwlist[] = { "data", "colorspace", "has_alpha",
			      "bits_per_sample", "width", "height",
			      "rowstride", NULL };
    const gchar *data;
    GdkColorspace colorspace;
    gboolean has_alpha;
    gint data_len, bits_per_sample, width, height, rowstride;
    gint required_len;
    gchar *data_copy;
    GdkPixbuf *pixbuf;
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				     "s#iiiiii:pixbuf_new_from_data", kwlist, 
				     &data, &data_len, &colorspace, 
				     &has_alpha, &bits_per_sample, 
				     &width, &height, &rowstride))
	return NULL;
    required_len = height*rowstride;
    if (data_len < required_len) {
	PyErr_Format(PyExc_ValueError, 
		      "data length (%d) is less then required by the other parameters (%d)", 
		      data_len, required_len);
	return NULL;
    }
    data_copy = g_try_malloc(required_len);
    if (!data_copy)
	return PyErr_NoMemory();
    memcpy(data_copy, data, required_len);
    pixbuf = gdk_pixbuf_new_from_data(data_copy, colorspace, has_alpha, 
				       bits_per_sample, width, height, 
				       rowstride, 
				       (GdkPixbufDestroyNotify )g_free, NULL);
    ret = pygobject_new((GObject *)pixbuf);
    g_object_unref(pixbuf);
    return ret;
}
%%
override gdk_pixbuf_new_from_array kwargs
static PyObject *
_wrap_gdk_pixbuf_new_from_array(PyObject *self, PyObject *args, 
				PyObject *kwargs)
{
#ifdef HAVE_NUMPY
    static char *kwlist[] = { "array", "colorspace", "bits_per_sample", NULL };
    PyArrayObject *array;
    GdkColorspace colorspace;
    gint bits_per_sample ;
    GdkPixbuf *pixbuf;
    PyObject *ret;
    gboolean has_alpha;
    gint width, height;
    gint i, j, nc, rs, st0, st1, st2;
    gchar *src, *dst;

    if (!have_numpy())
	return NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
				      "O!ii:pixbuf_new_from_array", kwlist, 
				      &PyArray_Type, &array, &colorspace, 
				      &bits_per_sample))
	return NULL;
    if (array->descr->type_num != PyArray_CHAR
	&& array->descr->type_num != PyArray_UBYTE) {
	PyErr_SetString(PyExc_TypeError, "array type must be 'c' or 'b'");
	return NULL;
    }
    if (array->nd != 3 || array->dimensions[2] < 3 || array->dimensions[2] > 4) {
	PyErr_SetString(PyExc_TypeError, "array shape must be (n,m,3) or (n,m,4)");
	return NULL;
    }
    height = array->dimensions[0];
    width = array->dimensions[1];
    has_alpha = array->dimensions[2] == 4;
    pixbuf = gdk_pixbuf_new(colorspace, has_alpha, bits_per_sample, 
			    width, height);
    src = (guchar*) array->data;
    dst = gdk_pixbuf_get_pixels(pixbuf);
    nc = gdk_pixbuf_get_n_channels(pixbuf);
    rs = gdk_pixbuf_get_rowstride(pixbuf);
    st0 = array->strides[0];
    st1 = array->strides[1];
    st2 = array->strides[2];
    if (has_alpha) {
	for (j = 0; j < height; j++) {
	    for (i = 0; i < width; i++) {
		dst[j*rs + i*4 + 0] = src[j*st0 + i*st1 + 0*st2];
		dst[j*rs + i*4 + 1] = src[j*st0 + i*st1 + 1*st2];
		dst[j*rs + i*4 + 2] = src[j*st0 + i*st1 + 2*st2];
		dst[j*rs + i*4 + 3] = src[j*st0 + i*st1 + 3*st2];
	    }
	}
    } else {
	for (j = 0; j < height; j++) {
	    for (i = 0; i < width; i++) {
		dst[j*rs + i*3 + 0] = src[j*st0 + i*st1 + 0*st2];
		dst[j*rs + i*3 + 1] = src[j*st0 + i*st1 + 1*st2];
		dst[j*rs + i*3 + 2] = src[j*st0 + i*st1 + 2*st2];
	    }
	}
    }
    ret = pygobject_new((GObject *)pixbuf);
    g_object_unref(pixbuf);
    return ret;

#else
    PyErr_SetString(PyExc_RuntimeError, "pygtk was not compiled with Numeric Python support");
    return NULL;
#endif
}
%%
override gdk_pixbuf_new_from_xpm_data kwargs
static PyObject *
_wrap_gdk_pixbuf_new_from_xpm_data(PyObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "data", NULL };
    PyObject *py_data, *ret;
    gchar **data;
    int len, i;
    GdkPixbuf *pixbuf;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!:pixbuf_new_from_xpm_data", kwlist,
                                     &PyList_Type, &py_data))
        return NULL;
    len = PyList_Size(py_data);
    data = g_new(gchar *, len);
    for (i = 0; i < len; i ++) {
        PyObject *item = PyList_GetItem(py_data, i);
        if (!PyString_Check(item)) {
            PyErr_SetString(PyExc_TypeError, "data items must be strings");
            g_free(data);
            return NULL;
        }
        data[i] = PyString_AsString(item);
    }
    pixbuf = gdk_pixbuf_new_from_xpm_data((const char**)data);
    g_free(data);
    if (pixbuf == NULL) {
        PyErr_SetString(PyExc_IOError, "can't load pixbuf");
        return NULL;
    }
    ret = pygobject_new((GObject *)pixbuf);
    g_object_unref(pixbuf);
    return ret;
}
%%
override gdk_gc_new2 kwargs
static PyObject *
_wrap_gdk_gc_new2(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", NULL };
    PyGObject *drawable;
    GdkGC *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O!:gc_new", kwlist, &PyGdkDrawable_Type, &drawable))
        return NULL;
    if (PyErr_Warn(PyExc_DeprecationWarning, "use gdk.GC or drawable.new_gc") < 0)
        return NULL;
    ret = gdk_gc_new(GDK_DRAWABLE(drawable->obj));
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gdk_devices_list noargs
static PyObject *
_wrap_gdk_devices_list(PyObject *self)
{
    GList * devlist,  *tmp;
    PyObject *list;

    devlist = gdk_devices_list();
    list = PyList_New(0);
    for (tmp = devlist; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new((GObject *)tmp->data);
        PyList_Append(list, item);
        Py_DECREF(item);
    }

    return list;
}
%%
override-attr GdkDrawable.handle
static PyObject *
_wrap_gdk_drawable__get_handle(PyGObject *self, void *closure)
{
#if defined(GDK_WINDOWING_WIN32)
    GdkDrawable *drawable = GDK_DRAWABLE(self->obj);
    return PyLong_FromVoidPtr(GDK_WINDOW_HWND(drawable));
#else
    PyErr_SetString(PyExc_AttributeError, "handle attribute not supported");
    return NULL;
#endif
}
%%
override-attr GdkDrawable.xid
static PyObject *
_wrap_gdk_drawable__get_xid(PyGObject *self, void *closure)
{
#if defined(GDK_WINDOWING_X11)
    GdkDrawable *drawable = GDK_DRAWABLE(self->obj);
    return PyLong_FromUnsignedLong(GDK_DRAWABLE_XID(drawable));
#else
    PyErr_SetString(PyExc_AttributeError, "xid attribute not supported");
    return NULL;
#endif
}
%%
override gdk_pixbuf_loader_new_with_type kwargs
static int
_wrap_gdk_pixbuf_loader_new_with_type(PyGObject *self,
                                      PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "image_type", NULL };
    char *image_type = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|s:GdkPixbufLoader.__init__",
				     kwlist, &image_type))
        return -1;

    if (image_type == NULL) {
	self->obj = (GObject *)gdk_pixbuf_loader_new();
    } else {
	GError *error = NULL;
	self->obj = (GObject *)gdk_pixbuf_loader_new_with_type(image_type,
							       &error);
	if (pyg_error_check(&error))
	    return -1;
    }

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
			"could not create GdkPixbufLoader object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gdk_pixbuf_loader_write kwargs
static PyObject *
_wrap_gdk_pixbuf_loader_write(PyGObject *self,
                              PyObject *args,
                              PyObject *kwargs)
{
    static char *kwlist[] = { "buf", "count", NULL };
    int buf_len, count = -1, ret;
    PyObject *py_ret;
    guchar *buf;
    GError *error = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s#|i:GdkPixbufLoader.write",
                                     kwlist, &buf, &buf_len, &count))
        return NULL;

    if (count < 0 || count > buf_len) {
        count = buf_len;
    }
    
    ret = gdk_pixbuf_loader_write(GDK_PIXBUF_LOADER(self->obj),
                                  buf, count, &error);
    
    if (pyg_error_check(&error))
        return NULL;
    
    py_ret = ret ? Py_True : Py_False;
    
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gdk_gc_new kwargs
static int
_wrap_gdk_gc_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", "foreground", "background", "font",
			      "function", "fill", "tile", "stipple",
			      "clip_mask", "subwindow_mode", "ts_x_origin",
			      "ts_y_origin", "clip_x_origin", "clip_y_origin",
			      "graphics_exposures", "line_width", "line_style",
			      "cap_style", "join_style", NULL };
    PyGObject *drawable;
    PyObject *foreground = Py_None, *background = Py_None;
    PyObject *font = Py_None;
    PyObject *tile = Py_None, *stipple = Py_None, *clip_mask = Py_None;
    gint function = -1, fill = -1;
    gint subwindow_mode = -1, ts_x_origin = -1, ts_y_origin = -1;
    gint clip_x_origin = -1, clip_y_origin = -1, graphics_exposures = -1;
    gint line_width = -1, line_style = -1, cap_style = -1, join_style = -1;
    GdkGCValues values;
    GdkGCValuesMask mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "O!|OOOiiOOOiiiiiiiiii:GdkGC.__init__",
				     kwlist, &PyGdkDrawable_Type, &drawable,
				     &foreground, &background, &font,
				     &function, &fill, &tile, &stipple,
				     &clip_mask, &subwindow_mode,
				     &ts_x_origin, &ts_y_origin,
				     &clip_x_origin, &clip_y_origin,
				     &graphics_exposures, &line_width,
				     &line_style, &cap_style, &join_style))
	return -1;
    if (pyg_boxed_check(foreground, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_FOREGROUND;
	values.foreground = *pyg_boxed_get(foreground, GdkColor);
    } else if (foreground != Py_None) {
	PyErr_SetString(PyExc_TypeError, "foreground must be a GdkColor");
	return -1;
    }
    if (pyg_boxed_check(background, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_BACKGROUND;
	values.background = *pyg_boxed_get(background, GdkColor);
    } else if (background != Py_None) {
	PyErr_SetString(PyExc_TypeError, "background must be a GdkColor");
	return -1;
    }
    if (pyg_boxed_check(font, GDK_TYPE_FONT)) {
	mask |= GDK_GC_FONT;
	values.font = pyg_boxed_get(font, GdkFont);
    } else if (font != Py_None) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return -1;
    }
    if (function != -1) {
	mask |= GDK_GC_FUNCTION;
	values.function = function;
    }
    if (fill != -1) {
	mask |= GDK_GC_FILL;
	values.fill = fill;
    }
    if (pygobject_check(tile, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_TILE;
	values.tile = GDK_PIXMAP(pygobject_get(tile));
    } else if (tile != Py_None) {
	PyErr_SetString(PyExc_TypeError, "tile must be a GdkPixmap");
	return -1;
    }
    if (pygobject_check(stipple, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_STIPPLE;
	values.stipple = GDK_PIXMAP(pygobject_get(stipple));
    } else if (stipple != Py_None) {
	PyErr_SetString(PyExc_TypeError, "stipple must be a GdkPixmap");
	return -1;
    }
    if (pygobject_check(clip_mask, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_CLIP_MASK;
	values.clip_mask = GDK_PIXMAP(pygobject_get(clip_mask));
    } else if (clip_mask != Py_None) {
	PyErr_SetString(PyExc_TypeError, "clip_mask must be a GdkPixmap");
	return -1;
    }
    if (subwindow_mode != -1) {
	mask |= GDK_GC_SUBWINDOW;
	values.subwindow_mode = subwindow_mode;
    }
    if (ts_x_origin != -1) {
	mask |= GDK_GC_TS_X_ORIGIN;
	values.ts_x_origin = ts_x_origin;
    }
    if (ts_y_origin != -1) {
	mask |= GDK_GC_TS_Y_ORIGIN;
	values.ts_y_origin = ts_y_origin;
    }
    if (clip_x_origin != -1) {
	mask |= GDK_GC_CLIP_X_ORIGIN;
	values.clip_x_origin = clip_x_origin;
    }
    if (clip_y_origin != -1) {
	mask |= GDK_GC_CLIP_Y_ORIGIN;
	values.clip_y_origin = clip_y_origin;
    }
    if (graphics_exposures != -1) {
	mask |= GDK_GC_EXPOSURES;
	values.graphics_exposures = graphics_exposures;
    }
    if (line_width != -1) {
	mask |= GDK_GC_LINE_WIDTH;
	values.line_width = line_width;
    }
    if (line_style != -1) {
	mask |= GDK_GC_LINE_STYLE;
	values.line_style = line_style;
    }
    if (cap_style != -1) {
	mask |= GDK_GC_CAP_STYLE;
	values.cap_style = cap_style;
    }
    if (join_style != -1) {
	mask |= GDK_GC_JOIN_STYLE;
	values.join_style = join_style;
    }
    self->obj = (GObject *)gdk_gc_new_with_values(GDK_DRAWABLE(drawable->obj),
						  &values, mask);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GdkGC object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gdk_gc_set_values kwargs
static PyObject *
_wrap_gdk_gc_set_values(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "foreground", "background", "font", "function",
			      "fill", "tile", "stipple", "clip_mask",
			      "subwindow_mode", "ts_x_origin", "ts_y_origin",
			      "clip_x_origin", "clip_y_origin",
			      "graphics_exposures", "line_width", "line_style",
			      "cap_style", "join_style", NULL };
    PyObject *foreground = Py_None, *background = Py_None;
    PyObject *font = Py_None;
    gint function = -1, fill = -1;
    PyObject *tile = Py_None, *stipple = Py_None, *clip_mask = Py_None;
    gint subwindow_mode = -1, ts_x_origin = -1, ts_y_origin = -1;
    gint clip_x_origin = -1, clip_y_origin = -1, graphics_exposures = -1;
    gint line_width = -1, line_style = -1, cap_style = -1, join_style = -1;
    GdkGCValues values;
    GdkGCValuesMask mask = 0;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|OOOiiOOOiiiiiiiiii:GdkGC.set_values",
				     kwlist, &foreground, &background, &font,
				     &function, &fill, &tile, &stipple,
				     &clip_mask, &subwindow_mode,
				     &ts_x_origin, &ts_y_origin,
				     &clip_x_origin, &clip_y_origin,
				     &graphics_exposures, &line_width,
				     &line_style, &cap_style, &join_style))
	return NULL;
    if (pyg_boxed_check(foreground, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_FOREGROUND;
	values.foreground = *pyg_boxed_get(foreground, GdkColor);
    } else if (foreground != Py_None) {
	PyErr_SetString(PyExc_TypeError, "foreground must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(background, GDK_TYPE_COLOR)) {
	mask |= GDK_GC_BACKGROUND;
	values.background = *pyg_boxed_get(background, GdkColor);
    } else if (background != Py_None) {
	PyErr_SetString(PyExc_TypeError, "background must be a GdkColor");
	return NULL;
    }
    if (pyg_boxed_check(font, GDK_TYPE_FONT)) {
	mask |= GDK_GC_FONT;
	values.font = pyg_boxed_get(font, GdkFont);
    } else if (font != Py_None) {
	PyErr_SetString(PyExc_TypeError, "font must be a GdkFont");
	return NULL;
    }
    if (function != -1) {
	mask |= GDK_GC_FUNCTION;
	values.function = function;
    }
    if (fill != -1) {
	mask |= GDK_GC_FILL;
	values.fill = fill;
    }
    if (pygobject_check(tile, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_TILE;
	values.tile = GDK_PIXMAP(pygobject_get(tile));
    } else if (tile != Py_None) {
	PyErr_SetString(PyExc_TypeError, "tile must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(stipple, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_STIPPLE;
	values.stipple = GDK_PIXMAP(pygobject_get(stipple));
    } else if (stipple != Py_None) {
	PyErr_SetString(PyExc_TypeError, "stipple must be a GdkPixmap");
	return NULL;
    }
    if (pygobject_check(clip_mask, &PyGdkPixmap_Type)) {
	mask |= GDK_GC_CLIP_MASK;
	values.clip_mask = GDK_PIXMAP(pygobject_get(clip_mask));
    } else if (clip_mask != Py_None) {
	PyErr_SetString(PyExc_TypeError, "clip_mask must be a GdkPixmap");
	return NULL;
    }
    if (subwindow_mode != -1) {
	mask |= GDK_GC_SUBWINDOW;
	values.subwindow_mode = subwindow_mode;
    }
    if (ts_x_origin != -1) {
	mask |= GDK_GC_TS_X_ORIGIN;
	values.ts_x_origin = ts_x_origin;
    }
    if (ts_y_origin != -1) {
	mask |= GDK_GC_TS_Y_ORIGIN;
	values.ts_y_origin = ts_y_origin;
    }
    if (clip_x_origin != -1) {
	mask |= GDK_GC_CLIP_X_ORIGIN;
	values.clip_x_origin = clip_x_origin;
    }
    if (clip_y_origin != -1) {
	mask |= GDK_GC_CLIP_Y_ORIGIN;
	values.clip_y_origin = clip_y_origin;
    }
    if (graphics_exposures != -1) {
	mask |= GDK_GC_EXPOSURES;
	values.graphics_exposures = graphics_exposures;
    }
    if (line_width != -1) {
	mask |= GDK_GC_LINE_WIDTH;
	values.line_width = line_width;
    }
    if (line_style != -1) {
	mask |= GDK_GC_LINE_STYLE;
	values.line_style = line_style;
    }
    if (cap_style != -1) {
	mask |= GDK_GC_CAP_STYLE;
	values.cap_style = cap_style;
    }
    if (join_style != -1) {
	mask |= GDK_GC_JOIN_STYLE;
	values.join_style = join_style;
    }
    gdk_gc_set_values(GDK_GC(self->obj), &values, mask);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_draw_layout kwargs
static PyObject *
_wrap_gdk_draw_layout(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "gc", "x", "y", "layout", "foreground",
			      "background", NULL };
    PyGObject *gc, *layout;
    int x, y;
    GdkColor *foreground = NULL, *background = NULL;
    PyObject *py_foreground = Py_None, *py_background = Py_None;

    if (!PyArg_ParseTupleAndKeywords(
	    args, kwargs, "O!iiO!|OO:GdkDrawable.draw_layout",
	    kwlist, &PyGdkGC_Type, &gc, &x, &y, &PyPangoLayout_Type, &layout,
	    &py_foreground, &py_background))
        return NULL;
    if (pyg_boxed_check(py_foreground, GDK_TYPE_COLOR))
        foreground = pyg_boxed_get(py_foreground, GdkColor);
    else if (py_foreground != Py_None) {
        PyErr_SetString(PyExc_TypeError,
			"foreground should be a GdkColor or None");
        return NULL;
    }
    if (pyg_boxed_check(py_background, GDK_TYPE_COLOR))
        background = pyg_boxed_get(py_background, GdkColor);
    else if (py_background != Py_None) {
        PyErr_SetString(PyExc_TypeError,
			"background should be a GdkColor or None");
        return NULL;
    }
    gdk_draw_layout_with_colors(GDK_DRAWABLE(self->obj), GDK_GC(gc->obj), x, y,
				PANGO_LAYOUT(layout->obj), foreground,
				background);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_pixbuf_animation_get_iter kwargs
static PyObject *
_wrap_gdk_pixbuf_animation_get_iter(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "start_time", NULL };
    GdkPixbufAnimationIter *ret;
    double start_time = 0.0;
    GTimeVal starttime, *starttimep;

    if (!PyArg_ParseTupleAndKeywords(
	    args, kwargs, "|d:GdkPixbufAnimation.get_iter",
	    kwlist, &start_time))
        return NULL;

    if (start_time > 0.0) {
	starttime.tv_sec = (glong) start_time;
	starttime.tv_usec = (glong)((start_time - starttime.tv_sec)
				    * G_USEC_PER_SEC);
	starttimep = &starttime;
    } else if (start_time == 0.0) {
	starttimep = NULL;
    } else {
        PyErr_SetString(PyExc_ValueError, "start_time must be >= 0.0");
        return NULL;
    }

    ret = gdk_pixbuf_animation_get_iter(GDK_PIXBUF_ANIMATION(self->obj),
					starttimep);
    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)ret);
}
%%
override gdk_pixbuf_animation_iter_advance kwargs
static PyObject *
_wrap_gdk_pixbuf_animation_iter_advance(PyGObject *self, PyObject *args,
				    PyObject *kwargs)
{
    static char *kwlist[] = { "current_time", NULL };
    gboolean ret;
    double current_time = 0.0;
    GTimeVal currenttime, *currenttimep;
    PyObject *py_ret;

    if (!PyArg_ParseTupleAndKeywords(
	    args, kwargs, "|d:GdkPixbufAnimationIter.advance",
	    kwlist, &current_time))
        return NULL;

    if (current_time > 0.0) {
	currenttime.tv_sec = (glong) current_time;
	currenttime.tv_usec = (glong)((current_time - currenttime.tv_sec)
				    * G_USEC_PER_SEC);
	currenttimep = &currenttime;
    } else if (current_time == 0.0) {
	currenttimep = NULL;
    } else {
        PyErr_SetString(PyExc_ValueError, "current_time must be >= 0.0");
        return NULL;
    }

    ret = gdk_pixbuf_animation_iter_advance(GDK_PIXBUF_ANIMATION_ITER(self->obj),
					    currenttimep);

    py_ret = ret ? Py_True : Py_False;
    
    Py_INCREF(py_ret);
    return py_ret;
}
%%
override gdk_pixbuf_get_formats noargs
static PyObject *
_wrap_gdk_pixbuf_get_formats(PyObject *self)
{
    GSList *list, *tmp;
    PyObject *ret;

    list = gdk_pixbuf_get_formats();
    ret = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
	GdkPixbufFormat *format = tmp->data;
	PyObject *item, *value;
	gchar *sval, **aval;
	gint i;

	item = PyDict_New();

	sval = gdk_pixbuf_format_get_name(format);
	value = PyString_FromString(sval);
	PyDict_SetItemString(item, "name", value);
	Py_DECREF(value);
	g_free(sval);

	sval = gdk_pixbuf_format_get_description(format);
	value = PyString_FromString(sval);
	PyDict_SetItemString(item, "description", value);
	Py_DECREF(value);
	g_free(sval);

	aval = gdk_pixbuf_format_get_mime_types(format);
	value = PyList_New(0);
	for (i = 0; aval[i] != NULL; i++) {
	    PyObject *string_item = PyString_FromString(aval[i]);
	    
	    PyList_Append(value, string_item);
	    Py_DECREF(string_item);
	}
	PyDict_SetItemString(item, "mime_types", value);
	Py_DECREF(value);
	g_strfreev(aval);

	aval = gdk_pixbuf_format_get_extensions(format);
	value = PyList_New(0);
	for (i = 0; aval[i] != NULL; i++) {
	    PyObject *string_item = PyString_FromString(aval[i]);
	    
	    PyList_Append(value, string_item);
	    Py_DECREF(string_item);
	}
	PyDict_SetItemString(item, "extensions", value);
	Py_DECREF(value);
	g_strfreev(aval);

	value = gdk_pixbuf_format_is_writable(format) ? Py_True : Py_False;
	PyDict_SetItemString(item, "is_writable", value);


	PyList_Append(ret, item);
	Py_DECREF(item);
    }

    g_slist_free(list);

    return ret;
}
%%
override gdk_rectangle_new kwargs
static int
_wrap_gdk_rectangle_new(PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "width", "height", NULL };
    GdkRectangle rect = {0, 0, 0, 0};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "|iiii:GdkRectangle.__init__",
				     kwlist, &(rect.x), &(rect.y),
				     &(rect.width), &(rect.height)))
	return -1;

    self->boxed =  g_boxed_copy(GDK_TYPE_RECTANGLE, &rect);
    self->free_on_dealloc = TRUE;
    self->gtype = GDK_TYPE_RECTANGLE;
    
    return 0;
}
%%
override gdk_window_get_frame_extents noargs
static PyObject *
_wrap_gdk_window_get_frame_extents(PyGObject *self)
{
    GdkRectangle rect = {0, 0, 0, 0};

    gdk_window_get_frame_extents(GDK_WINDOW(self->obj), &rect);

    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &rect, TRUE, TRUE);
}
%%
override gdk_window_get_decorations noargs
static PyObject *
_wrap_gdk_window_get_decorations(PyGObject *self)
{
    GdkWMDecoration decor = 0; 

    gdk_window_get_decorations(GDK_WINDOW(self->obj), &decor);

    return PyInt_FromLong(decor);
}
%%
override gdk_window_get_toplevels noargs
static PyObject *
_wrap_gdk_window_get_toplevels(PyGObject *self)
{
    GList *topl;
    guint ntopl;
    int i;
    PyObject *list;

    topl = gdk_window_get_toplevels();
    ntopl = g_list_length(topl);

    if ((list = PyList_New(ntopl)) == NULL)
	return NULL;

    for (i = 0; i < ntopl; i++) {
	PyObject *item;

	item = pygobject_new((GObject *)g_list_nth_data(topl, i));
	PyList_SetItem(list, i, item);
    }

    g_list_free(topl);

    return list;
}
%%
override gdk_list_visuals noargs
static PyObject *
_wrap_gdk_list_visuals(PyGObject *self)
{
    GList *visl;
    guint nvisl;
    int i;
    PyObject *list;

    visl = gdk_list_visuals();
    nvisl = g_list_length(visl);

    if ((list = PyList_New(nvisl)) == NULL)
	return NULL;

    for (i = 0; i < nvisl; i++) {
	PyObject *item;

	item = pygobject_new((GObject *)g_list_nth_data(visl, i));
	PyList_SetItem(list, i, item);
    }

    g_list_free(visl);

    return list;
}
%%
override gdk_window_new kwargs
static int
_wrap_gdk_window_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "parent", "width", "height", "window_type",
			      "event_mask", "wclass", "title", "x", "y",
			      "visual", "colormap", "cursor", "wmclass_name",
			      "wmclass_class", "override_redirect", NULL };
    GdkWindowAttr attr = { NULL, 0, -1, -1, 0, 0, -1, NULL, NULL, 0, NULL,
			   NULL, NULL, -1 };
    guint attr_mask = 0;
    GdkWindow *parent = NULL;
    PyGObject *py_parent = NULL, *py_visual = NULL, *py_colormap = NULL;
    PyGObject *py_cursor = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "Oiiiii|siiO!O!Ossi:GdkWindow.__init__",
				     kwlist, &py_parent, &attr.width,
				     &attr.height, &attr.window_type,
				     &attr.event_mask, &attr.wclass,
				     &attr.title, &attr.x, &attr.y,
				     &PyGdkVisual_Type, &py_visual,
				     &PyGdkColormap_Type, &py_colormap,
				     &py_cursor,
				     &attr.wmclass_name, &attr.wmclass_class,
				     &attr.override_redirect))
	return -1;

    if (py_parent && pygobject_check(py_parent, &PyGdkWindow_Type))
        parent = GDK_WINDOW(py_parent->obj);
    else if ((PyObject *)py_parent != Py_None) {
        PyErr_SetString(PyExc_TypeError, "parent must be a GdkWindow or None");
        return -1;
    }
    if (attr.title)
	attr_mask |= GDK_WA_TITLE;
    if (attr.x != -1)
	attr_mask |= GDK_WA_X;
    if (attr.y != -1)
	attr_mask |= GDK_WA_Y;
    if (py_visual) {
	attr.visual = GDK_VISUAL(py_visual->obj);
	attr_mask |= GDK_WA_VISUAL;
    }
    if (py_colormap) {
	attr.colormap = GDK_COLORMAP(py_colormap->obj);
	attr_mask |= GDK_WA_COLORMAP;
    }
    if (py_cursor) {
	if (!pyg_boxed_check(py_cursor, GDK_TYPE_CURSOR)) {
	    PyErr_SetString(PyExc_TypeError, "cursor should be a GdkCursor");
	    return -1;
	}
	attr.cursor = pyg_boxed_get(py_cursor, GdkCursor);
	attr_mask |= GDK_WA_CURSOR;
    }
    if (attr.wmclass_name && attr.wmclass_class)
	attr_mask |= GDK_WA_WMCLASS;
    if (attr.override_redirect != -1)
	attr_mask |= GDK_WA_NOREDIR;

    self->obj = (GObject *)gdk_window_new(parent, &attr, attr_mask);
    if (!self->obj) {
	PyErr_SetString(PyExc_RuntimeError,
			"could not create GdkWindow object");
	return -1;
    }
#ifdef PLATFORM_WIN32
    g_object_ref(self->obj);
#endif
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override gdk_display_list_devices noargs
static PyObject *
_wrap_gdk_display_list_devices(PyGObject *self)
{
    GList * devlist,  *tmp;
    PyObject *list;

    devlist = gdk_display_list_devices(GDK_DISPLAY_OBJECT(self->obj));
    list = PyList_New(0);
    for (tmp = devlist; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new((GObject *)tmp->data);
        PyList_Append(list, item);
        Py_DECREF(item);
    }

    return list;
}
%%
override gdk_display_get_pointer noargs
static PyObject *
_wrap_gdk_display_get_pointer(PyGObject *self)
{
    GdkScreen *screen = NULL;
    gint x, y;
    GdkModifierType mask;

    gdk_display_get_pointer(GDK_DISPLAY_OBJECT(self->obj), &screen, &x, &y, &mask);
    return Py_BuildValue("(Niii)", pygobject_new((GObject *)screen),
			 x, y, (gint)mask);
}
%%
override gdk_display_get_window_at_pointer noargs
static PyObject *
_wrap_gdk_display_get_window_at_pointer(PyGObject *self)
{
    GdkWindow *window;
    gint win_x, win_y;

    window = gdk_display_get_window_at_pointer(GDK_DISPLAY_OBJECT(self->obj),
					       &win_x, &win_y);
    if (window)
	return Py_BuildValue("(Nii)", pygobject_new((GObject *)window),
			     win_x, win_y);
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_display_manager_list_displays noargs
static PyObject *
_wrap_gdk_display_manager_list_displays(PyGObject *self)
{
    GSList *list, *tmp;
    PyObject *py_list;

    list = gdk_display_manager_list_displays(GDK_DISPLAY_MANAGER(self->obj));
    py_list = PyList_New(0);
    for (tmp = list; tmp != NULL; tmp = tmp->next) {
        PyObject *item = pygobject_new((GObject *)tmp->data);
        PyList_Append(py_list, item);
        Py_DECREF(item);
    }
    g_slist_free(list);

    return py_list;
}
%%
override gdk_screen_list_visuals noargs
static PyObject *
_wrap_gdk_screen_list_visuals(PyGObject *self)
{
    GList *visl;
    guint nvisl;
    int i;
    PyObject *list;

    visl = gdk_screen_list_visuals(GDK_SCREEN(self->obj));
    nvisl = g_list_length(visl);

    if ((list = PyList_New(nvisl)) == NULL)
	return NULL;

    for (i = 0; i < nvisl; i++) {
	PyObject *item;

	item = pygobject_new((GObject *)g_list_nth_data(visl, i));
	PyList_SetItem(list, i, item);
    }

    g_list_free(visl);

    return list;
}
%%
override gdk_screen_get_toplevel_windows noargs
static PyObject *
_wrap_gdk_screen_get_toplevel_windows(PyGObject *self)
{
    GList *topl;
    guint ntopl;
    int i;
    PyObject *list;

    topl = gdk_screen_get_toplevel_windows(GDK_SCREEN(self->obj));
    ntopl = g_list_length(topl);

    if ((list = PyList_New(ntopl)) == NULL)
	return NULL;

    for (i = 0; i < ntopl; i++) {
	PyObject *item;

	item = pygobject_new((GObject *)g_list_nth_data(topl, i));
	PyList_SetItem(list, i, item);
    }

    g_list_free(topl);

    return list;
}
%%
override gdk_screen_get_monitor_geometry kwargs
static PyObject *
_wrap_gdk_screen_get_monitor_geometry(PyGObject *self, PyObject *args,
				      PyObject *kwargs)
{
    static char *kwlist[] = { "monitor_num", NULL };
    int monitor_num;
    GdkRectangle dest = { 0, 0, 0, 0 };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
				     "i:GdkScreen.get_monitor_geometry",
				     kwlist, &monitor_num))
        return NULL;

    gdk_screen_get_monitor_geometry(GDK_SCREEN(self->obj), monitor_num, &dest);

    return pyg_boxed_new(GDK_TYPE_RECTANGLE, &dest, TRUE, TRUE);
}
%%
override gdk_screen_get_setting kwargs
static PyObject *
_wrap_gdk_screen_get_setting(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "name", NULL };
    char *name;
    GValue value = { 0, };
    PyObject *ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GdkScreen.get_setting",
				     kwlist, &name))
	return NULL;

    /* this is a bit of a hack.  We don't know what type of setting it is */
    g_value_init(&value, GDK_TYPE_COLOR);
    if (gdk_screen_get_setting(GDK_SCREEN(self->obj), name, &value))
	goto got_setting;
    g_value_unset(&value);
    g_value_init(&value, G_TYPE_INT);
    if (gdk_screen_get_setting(GDK_SCREEN(self->obj), name, &value))
	goto got_setting;
    g_value_unset(&value);
    g_value_init(&value, G_TYPE_STRING);
    if (gdk_screen_get_setting(GDK_SCREEN(self->obj), name, &value))
	goto got_setting;
    g_value_unset(&value);
    /* setting not found */
    PyErr_SetString(PyExc_ValueError, "could not find setting");
    return NULL;

 got_setting:
    ret = pyg_value_as_pyobject(&value, TRUE);
    g_value_unset(&value);
    return ret;
}
%%
override gdk_pixbuf_fill kwargs
static PyObject *
_wrap_gdk_pixbuf_fill(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "pixel", NULL };
    PyObject *py_pixel = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GdkPixbuf.fill", kwlist, &py_pixel))
        return NULL;
    
    if (PyInt_Check(py_pixel))
	gdk_pixbuf_fill(GDK_PIXBUF(self->obj), PyInt_AsLong(py_pixel));
    else if (PyLong_Check(py_pixel))
	gdk_pixbuf_fill(GDK_PIXBUF(self->obj), PyLong_AsUnsignedLong(py_pixel));
    else {
	PyErr_SetString(PyExc_TypeError, "pixel must be an int or a long");
	return NULL;
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_window_add_filter kwargs
static int
pygdk_filter_func_marshal(GdkXEvent *xevent,
			  GdkEvent *event,
			  PyGtkCustomNotify *cunote)
{
    PyObject *ret;
    PyObject *pyevent;
    int retval;
    
    pyg_block_threads();
    pyevent = pyg_boxed_new(GDK_TYPE_EVENT, event, TRUE, TRUE);

    if (cunote->data)
        ret = PyObject_CallFunction(cunote->func, "OO", pyevent, cunote->data);

    else
        ret = PyObject_CallFunction(cunote->func, "O", pyevent);
    
    if (ret == NULL) {
        PyErr_Print();
	retval = PyInt_AsLong(GDK_FILTER_CONTINUE);
    } else {
	retval = PyInt_AsLong(ret);
    }
    
    pyg_unblock_threads();
    return retval;
}
static PyObject*
_wrap_gdk_window_add_filter(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "entries", "callback_data", NULL };
    PyGtkCustomNotify *cunote;
    PyObject *pyfunc, *pydata = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:GdkWindow.add_filter", kwlist,
                                     &pyfunc, &pydata))
        return NULL;
     
    
    cunote = g_new0(PyGtkCustomNotify, 1);
    cunote->func = pyfunc;
    cunote->data = pydata;
    Py_INCREF(cunote->func);
    Py_XINCREF(cunote->data);

    pyg_block_threads();
    g_object_weak_ref(G_OBJECT(self->obj),
		      (GWeakNotify) pygtk_custom_destroy_notify,
		      cunote);
    pyg_unblock_threads();
    
    gdk_window_add_filter (GDK_WINDOW(self->obj),
			   (GdkFilterFunc)pygdk_filter_func_marshal,
			   cunote);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override gdk_atom_intern kwargs
static PyObject *
_wrap_gdk_atom_intern(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "atom_name", "only_if_exists", NULL };
    char *atom_name;
    int only_if_exists = FALSE;
    GdkAtom ret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s|i:atom_intern",
				     kwlist, &atom_name, &only_if_exists))
        return NULL;
    ret = gdk_atom_intern(atom_name, only_if_exists);
    if (ret == GDK_NONE) {
	Py_INCREF(Py_None);
	return Py_None;
    }
    return PyGdkAtom_New(ret);
}
